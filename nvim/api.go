// Code generated by running "go generate" in github.com/neovim/go-client/nvim. DO NOT EDIT.

package nvim

import (
	"fmt"

	"github.com/neovim/go-client/msgpack"
	"github.com/neovim/go-client/msgpack/rpc"
)

const (
	exceptionError  = 0
	validationError = 1
)

func withExtensions() rpc.Option {
	return rpc.WithExtensions(msgpack.ExtensionMap{
		0: func(p []byte) (any, error) {
			x, err := decodeExt(p)
			return Buffer(x), err
		},

		2: func(p []byte) (any, error) {
			x, err := decodeExt(p)
			return Tabpage(x), err
		},

		1: func(p []byte) (any, error) {
			x, err := decodeExt(p)
			return Window(x), err
		},
	})
}

// Buffer represents a Nvim buffer.
type Buffer int

// MarshalMsgPack implements msgpack.Marshaler.
func (x Buffer) MarshalMsgPack(enc *msgpack.Encoder) error {
	return enc.PackExtension(0, encodeExt(int(x)))
}

// UnmarshalMsgPack implements msgpack.Unmarshaler.
func (x *Buffer) UnmarshalMsgPack(dec *msgpack.Decoder) error {
	n, err := unmarshalExt(dec, 0, x)
	*x = Buffer(n)
	return err
}

// String returns a string representation of the Buffer.
func (x Buffer) String() string {
	return fmt.Sprintf("Buffer:%d", int(x))
}

// Tabpage represents a Nvim tabpage.
type Tabpage int

// MarshalMsgPack implements msgpack.Marshaler.
func (x Tabpage) MarshalMsgPack(enc *msgpack.Encoder) error {
	return enc.PackExtension(2, encodeExt(int(x)))
}

// UnmarshalMsgPack implements msgpack.Unmarshaler.
func (x *Tabpage) UnmarshalMsgPack(dec *msgpack.Decoder) error {
	n, err := unmarshalExt(dec, 2, x)
	*x = Tabpage(n)
	return err
}

// String returns a string representation of the Tabpage.
func (x Tabpage) String() string {
	return fmt.Sprintf("Tabpage:%d", int(x))
}

// Window represents a Nvim window.
type Window int

// MarshalMsgPack implements msgpack.Marshaler.
func (x Window) MarshalMsgPack(enc *msgpack.Encoder) error {
	return enc.PackExtension(1, encodeExt(int(x)))
}

// UnmarshalMsgPack implements msgpack.Unmarshaler.
func (x *Window) UnmarshalMsgPack(dec *msgpack.Decoder) error {
	n, err := unmarshalExt(dec, 1, x)
	*x = Window(n)
	return err
}

// String returns a string representation of the Window.
func (x Window) String() string {
	return fmt.Sprintf("Window:%d", int(x))
}

// Autocmds get all autocommands that match the corresponding {opts}.
//
// Note that when multiple patterns or events are provided, it will find all the autocommands that
// match any combination of them.
//
// See: [nvim_get_autocmds()]
//
// [nvim_get_autocmds()]: https://neovim.io/doc/user/api.html#nvim_get_autocmds()
func (v *Nvim) Autocmds(opts map[string]any) (result []*AutocmdType, err error) {
	err = v.call("nvim_get_autocmds", &result, opts)
	return result, err
}

// Autocmds get all autocommands that match the corresponding {opts}.
//
// Note that when multiple patterns or events are provided, it will find all the autocommands that
// match any combination of them.
//
// See: [nvim_get_autocmds()]
//
// [nvim_get_autocmds()]: https://neovim.io/doc/user/api.html#nvim_get_autocmds()
func (b *Batch) Autocmds(opts map[string]any, result *[]*AutocmdType) {
	b.call("nvim_get_autocmds", result, opts)
}

// CreateAutocmd create an autocommand.
//
// The API allows for two (mutually exclusive) types of actions to be executed when the autocommand
// triggers: a callback function (Lua or Vimscript), or a command (like regular autocommands).
//
// See: [nvim_create_autocmd()]
//
// [nvim_create_autocmd()]: https://neovim.io/doc/user/api.html#nvim_create_autocmd()
func (v *Nvim) CreateAutocmd(event any, opts map[string]any) (id int, err error) {
	err = v.call("nvim_create_autocmd", &id, event, opts)
	return id, err
}

// CreateAutocmd create an autocommand.
//
// The API allows for two (mutually exclusive) types of actions to be executed when the autocommand
// triggers: a callback function (Lua or Vimscript), or a command (like regular autocommands).
//
// See: [nvim_create_autocmd()]
//
// [nvim_create_autocmd()]: https://neovim.io/doc/user/api.html#nvim_create_autocmd()
func (b *Batch) CreateAutocmd(event any, opts map[string]any, id *int) {
	b.call("nvim_create_autocmd", id, event, opts)
}

// DeleteAutocmd delete an autocommand by id.
//
// NOTE: Only autocommands created via the API have an id.
//
// See: [nvim_del_autocmd()]
//
// [nvim_del_autocmd()]: https://neovim.io/doc/user/api.html#nvim_del_autocmd()
func (v *Nvim) DeleteAutocmd(id int) error {
	return v.call("nvim_del_autocmd", nil, id)
}

// DeleteAutocmd delete an autocommand by id.
//
// NOTE: Only autocommands created via the API have an id.
//
// See: [nvim_del_autocmd()]
//
// [nvim_del_autocmd()]: https://neovim.io/doc/user/api.html#nvim_del_autocmd()
func (b *Batch) DeleteAutocmd(id int) {
	b.call("nvim_del_autocmd", nil, id)
}

// ClearAutocmds clear all autocommands that match the corresponding {opts}.
//
// To delete a particular autocmd, see DeleteAutocmd.
//
// See: [nvim_clear_autocmds()]
//
// [nvim_clear_autocmds()]: https://neovim.io/doc/user/api.html#nvim_clear_autocmds()
func (v *Nvim) ClearAutocmds(opts map[string]any) error {
	return v.call("nvim_clear_autocmds", nil, opts)
}

// ClearAutocmds clear all autocommands that match the corresponding {opts}.
//
// To delete a particular autocmd, see DeleteAutocmd.
//
// See: [nvim_clear_autocmds()]
//
// [nvim_clear_autocmds()]: https://neovim.io/doc/user/api.html#nvim_clear_autocmds()
func (b *Batch) ClearAutocmds(opts map[string]any) {
	b.call("nvim_clear_autocmds", nil, opts)
}

// CreateAugroup create or get an autocommand group(autocmd-groups).
//
// See: [nvim_create_augroup()]
//
// [nvim_create_augroup()]: https://neovim.io/doc/user/api.html#nvim_create_augroup()
func (v *Nvim) CreateAugroup(name string, opts map[string]any) (id int, err error) {
	err = v.call("nvim_create_augroup", &id, name, opts)
	return id, err
}

// CreateAugroup create or get an autocommand group(autocmd-groups).
//
// See: [nvim_create_augroup()]
//
// [nvim_create_augroup()]: https://neovim.io/doc/user/api.html#nvim_create_augroup()
func (b *Batch) CreateAugroup(name string, opts map[string]any, id *int) {
	b.call("nvim_create_augroup", id, name, opts)
}

// DeleteAugroupByID delete an autocommand group by id.
//
// See: [nvim_del_augroup_by_id()]
//
// [nvim_del_augroup_by_id()]: https://neovim.io/doc/user/api.html#nvim_del_augroup_by_id()
func (v *Nvim) DeleteAugroupByID(id int) error {
	return v.call("nvim_del_augroup_by_id", nil, id)
}

// DeleteAugroupByID delete an autocommand group by id.
//
// See: [nvim_del_augroup_by_id()]
//
// [nvim_del_augroup_by_id()]: https://neovim.io/doc/user/api.html#nvim_del_augroup_by_id()
func (b *Batch) DeleteAugroupByID(id int) {
	b.call("nvim_del_augroup_by_id", nil, id)
}

// DeleteAugroupByID delete an autocommand group by name.
//
// See: [nvim_del_augroup_by_name()]
//
// [nvim_del_augroup_by_name()]: https://neovim.io/doc/user/api.html#nvim_del_augroup_by_name()
func (v *Nvim) DeleteAugroupByName(name string) error {
	return v.call("nvim_del_augroup_by_name", nil, name)
}

// DeleteAugroupByID delete an autocommand group by name.
//
// See: [nvim_del_augroup_by_name()]
//
// [nvim_del_augroup_by_name()]: https://neovim.io/doc/user/api.html#nvim_del_augroup_by_name()
func (b *Batch) DeleteAugroupByName(name string) {
	b.call("nvim_del_augroup_by_name", nil, name)
}

// ExecAutocmds execute all autocommands for {event} that match the corresponding {opts} autocmd-execute.
//
// See: [nvim_exec_autocmds()]
//
// [nvim_exec_autocmds()]: https://neovim.io/doc/user/api.html#nvim_exec_autocmds()
func (v *Nvim) ExecAutocmds(event any, opts map[string]any) error {
	return v.call("nvim_exec_autocmds", nil, event, opts)
}

// ExecAutocmds execute all autocommands for {event} that match the corresponding {opts} autocmd-execute.
//
// See: [nvim_exec_autocmds()]
//
// [nvim_exec_autocmds()]: https://neovim.io/doc/user/api.html#nvim_exec_autocmds()
func (b *Batch) ExecAutocmds(event any, opts map[string]any) {
	b.call("nvim_exec_autocmds", nil, event, opts)
}

// BufferLineCount gets the buffer line count.
//
// The buffer arg is specific Buffer, or 0 for current buffer.
//
// The returns line count, or 0 for unloaded buffer.
//
// See: [nvim_buf_line_count()]
//
// [nvim_buf_line_count()]: https://neovim.io/doc/user/api.html#nvim_buf_line_count()
func (v *Nvim) BufferLineCount(buffer Buffer) (count int, err error) {
	err = v.call("nvim_buf_line_count", &count, buffer)
	return count, err
}

// BufferLineCount gets the buffer line count.
//
// The buffer arg is specific Buffer, or 0 for current buffer.
//
// The returns line count, or 0 for unloaded buffer.
//
// See: [nvim_buf_line_count()]
//
// [nvim_buf_line_count()]: https://neovim.io/doc/user/api.html#nvim_buf_line_count()
func (b *Batch) BufferLineCount(buffer Buffer, count *int) {
	b.call("nvim_buf_line_count", count, buffer)
}

// AttachBuffer activates buffer-update events on a channel.
//
// The buffer is specific Buffer, or 0 for current buffer.
//
// If sendBuffer is true, initial notification should contain the whole buffer.
// If false, the first notification will be a "nvim_buf_lines_event".
// Otherwise, the first notification will be a "nvim_buf_changedtick_event".
//
// Returns whether the updates couldn't be enabled because the buffer isn't loaded or opts contained an invalid key.
//
// See: [nvim_buf_attach()]
//
// [nvim_buf_attach()]: https://neovim.io/doc/user/api.html#nvim_buf_attach()
func (v *Nvim) AttachBuffer(buffer Buffer, sendBuffer bool, opts map[string]any) (attached bool, err error) {
	err = v.call("nvim_buf_attach", &attached, buffer, sendBuffer, opts)
	return attached, err
}

// AttachBuffer activates buffer-update events on a channel.
//
// The buffer is specific Buffer, or 0 for current buffer.
//
// If sendBuffer is true, initial notification should contain the whole buffer.
// If false, the first notification will be a "nvim_buf_lines_event".
// Otherwise, the first notification will be a "nvim_buf_changedtick_event".
//
// Returns whether the updates couldn't be enabled because the buffer isn't loaded or opts contained an invalid key.
//
// See: [nvim_buf_attach()]
//
// [nvim_buf_attach()]: https://neovim.io/doc/user/api.html#nvim_buf_attach()
func (b *Batch) AttachBuffer(buffer Buffer, sendBuffer bool, opts map[string]any, attached *bool) {
	b.call("nvim_buf_attach", attached, buffer, sendBuffer, opts)
}

// DetachBuffer deactivate updates from this buffer to the current channel.
//
// Returns whether the updates couldn't be disabled because the buffer isn't loaded.
//
// See: [nvim_buf_detach()]
//
// [nvim_buf_detach()]: https://neovim.io/doc/user/api.html#nvim_buf_detach()
func (v *Nvim) DetachBuffer(buffer Buffer) (detached bool, err error) {
	err = v.call("nvim_buf_detach", &detached, buffer)
	return detached, err
}

// DetachBuffer deactivate updates from this buffer to the current channel.
//
// Returns whether the updates couldn't be disabled because the buffer isn't loaded.
//
// See: [nvim_buf_detach()]
//
// [nvim_buf_detach()]: https://neovim.io/doc/user/api.html#nvim_buf_detach()
func (b *Batch) DetachBuffer(buffer Buffer, detached *bool) {
	b.call("nvim_buf_detach", detached, buffer)
}

// BufferLines gets a line-range from the buffer.
//
// Indexing is zero-based, end-exclusive.
// Negative indices are interpreted as length+1+index: -1 refers to the index past the end.
// So to get the last element use start=-2 and end=-1.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless strictIndexing is set.
//
// See: [nvim_buf_get_lines()]
//
// [nvim_buf_get_lines()]: https://neovim.io/doc/user/api.html#nvim_buf_get_lines()
func (v *Nvim) BufferLines(buffer Buffer, start int, end int, strictIndexing bool) (lines [][]byte, err error) {
	err = v.call("nvim_buf_get_lines", &lines, buffer, start, end, strictIndexing)
	return lines, err
}

// BufferLines gets a line-range from the buffer.
//
// Indexing is zero-based, end-exclusive.
// Negative indices are interpreted as length+1+index: -1 refers to the index past the end.
// So to get the last element use start=-2 and end=-1.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless strictIndexing is set.
//
// See: [nvim_buf_get_lines()]
//
// [nvim_buf_get_lines()]: https://neovim.io/doc/user/api.html#nvim_buf_get_lines()
func (b *Batch) BufferLines(buffer Buffer, start int, end int, strictIndexing bool, lines *[][]byte) {
	b.call("nvim_buf_get_lines", lines, buffer, start, end, strictIndexing)
}

// SetBufferLines sets or replaces a line-range in the buffer.
//
// Indexing is zero-based, end-exclusive.
// Negative indices are interpreted as length+1+index: -1 refers to the index past the end.
// So to change or delete the last element use start=-2 and end=-1.
//
// To insert lines at a given index, set start and end args to the same index.
//
// To delete a range of lines, set replacement arg to an empty array.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless
// strict_indexing arg is set to true.
//
// See: [nvim_buf_set_lines()]
//
// [nvim_buf_set_lines()]: https://neovim.io/doc/user/api.html#nvim_buf_set_lines()
func (v *Nvim) SetBufferLines(buffer Buffer, start int, end int, strictIndexing bool, replacement [][]byte) error {
	return v.call("nvim_buf_set_lines", nil, buffer, start, end, strictIndexing, replacement)
}

// SetBufferLines sets or replaces a line-range in the buffer.
//
// Indexing is zero-based, end-exclusive.
// Negative indices are interpreted as length+1+index: -1 refers to the index past the end.
// So to change or delete the last element use start=-2 and end=-1.
//
// To insert lines at a given index, set start and end args to the same index.
//
// To delete a range of lines, set replacement arg to an empty array.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless
// strict_indexing arg is set to true.
//
// See: [nvim_buf_set_lines()]
//
// [nvim_buf_set_lines()]: https://neovim.io/doc/user/api.html#nvim_buf_set_lines()
func (b *Batch) SetBufferLines(buffer Buffer, start int, end int, strictIndexing bool, replacement [][]byte) {
	b.call("nvim_buf_set_lines", nil, buffer, start, end, strictIndexing, replacement)
}

// SetBufferText sets or replaces a range in the buffer.
//
// This is recommended over SetBufferLines when only modifying parts of a
// line, as extmarks will be preserved on non-modified parts of the touched
// lines.
//
// Indexing is zero-based and end-exclusive.
//
// To insert text at a given index, set startRow and endRow args ranges to the same index.
//
// To delete a range, set replacement arg to an array containing an empty string, or simply an empty array.
//
// Prefer SetBufferLines when adding or deleting entire lines only.
//
// See: [nvim_buf_set_text()]
//
// [nvim_buf_set_text()]: https://neovim.io/doc/user/api.html#nvim_buf_set_text()
func (v *Nvim) SetBufferText(buffer Buffer, startRow int, startCol int, endRow int, endCol int, replacement [][]byte) error {
	return v.call("nvim_buf_set_text", nil, buffer, startRow, startCol, endRow, endCol, replacement)
}

// SetBufferText sets or replaces a range in the buffer.
//
// This is recommended over SetBufferLines when only modifying parts of a
// line, as extmarks will be preserved on non-modified parts of the touched
// lines.
//
// Indexing is zero-based and end-exclusive.
//
// To insert text at a given index, set startRow and endRow args ranges to the same index.
//
// To delete a range, set replacement arg to an array containing an empty string, or simply an empty array.
//
// Prefer SetBufferLines when adding or deleting entire lines only.
//
// See: [nvim_buf_set_text()]
//
// [nvim_buf_set_text()]: https://neovim.io/doc/user/api.html#nvim_buf_set_text()
func (b *Batch) SetBufferText(buffer Buffer, startRow int, startCol int, endRow int, endCol int, replacement [][]byte) {
	b.call("nvim_buf_set_text", nil, buffer, startRow, startCol, endRow, endCol, replacement)
}

// BufferText gets a range from the buffer.
//
// This differs from BufferLines in that it allows retrieving only
// portions of a line.
//
// Indexing is zero-based. Column indices are end-exclusive.
//
// Prefer BufferLines when retrieving entire lines.
//
// opts is optional parameters. Currently unused.
//
// See: [nvim_buf_get_text()]
//
// [nvim_buf_get_text()]: https://neovim.io/doc/user/api.html#nvim_buf_get_text()
func (v *Nvim) BufferText(buffer Buffer, startRow int, startCol int, endRow int, endCol int, opts map[string]any) ([][]byte, error) {
	var result [][]byte
	err := v.call("nvim_buf_get_text", &result, buffer, startRow, startCol, endRow, endCol, opts)
	return result, err
}

// BufferText gets a range from the buffer.
//
// This differs from BufferLines in that it allows retrieving only
// portions of a line.
//
// Indexing is zero-based. Column indices are end-exclusive.
//
// Prefer BufferLines when retrieving entire lines.
//
// opts is optional parameters. Currently unused.
//
// See: [nvim_buf_get_text()]
//
// [nvim_buf_get_text()]: https://neovim.io/doc/user/api.html#nvim_buf_get_text()
func (b *Batch) BufferText(buffer Buffer, startRow int, startCol int, endRow int, endCol int, opts map[string]any, result *[][]byte) {
	b.call("nvim_buf_get_text", result, buffer, startRow, startCol, endRow, endCol, opts)
}

// BufferOffset returns the byte offset of a line (0-indexed).
//
// Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.
// "fileformat" and "fileencoding" are ignored.
//
// The line index just after the last line gives the total byte-count of the buffer.
// A final EOL byte is counted if it would be written, see ":help eol".
//
// Unlike "line2byte" vim function, throws error for out-of-bounds indexing.
//
// If Buffer is unloaded buffer, returns -1.
//
// See: [nvim_buf_get_offset()]
//
// [nvim_buf_get_offset()]: https://neovim.io/doc/user/api.html#nvim_buf_get_offset()
func (v *Nvim) BufferOffset(buffer Buffer, index int) (offset int, err error) {
	err = v.call("nvim_buf_get_offset", &offset, buffer, index)
	return offset, err
}

// BufferOffset returns the byte offset of a line (0-indexed).
//
// Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.
// "fileformat" and "fileencoding" are ignored.
//
// The line index just after the last line gives the total byte-count of the buffer.
// A final EOL byte is counted if it would be written, see ":help eol".
//
// Unlike "line2byte" vim function, throws error for out-of-bounds indexing.
//
// If Buffer is unloaded buffer, returns -1.
//
// See: [nvim_buf_get_offset()]
//
// [nvim_buf_get_offset()]: https://neovim.io/doc/user/api.html#nvim_buf_get_offset()
func (b *Batch) BufferOffset(buffer Buffer, index int, offset *int) {
	b.call("nvim_buf_get_offset", offset, buffer, index)
}

// BufferVar gets a buffer-scoped (b:) variable.
//
// See: [nvim_buf_get_var()]
//
// [nvim_buf_get_var()]: https://neovim.io/doc/user/api.html#nvim_buf_get_var()
func (v *Nvim) BufferVar(buffer Buffer, name string, result any) error {
	return v.call("nvim_buf_get_var", result, buffer, name)
}

// BufferVar gets a buffer-scoped (b:) variable.
//
// See: [nvim_buf_get_var()]
//
// [nvim_buf_get_var()]: https://neovim.io/doc/user/api.html#nvim_buf_get_var()
func (b *Batch) BufferVar(buffer Buffer, name string, result any) {
	b.call("nvim_buf_get_var", &result, buffer, name)
}

// BufferChangedTick gets a changed tick of a buffer.
//
// See: [nvim_buf_get_changedtick()]
//
// [nvim_buf_get_changedtick()]: https://neovim.io/doc/user/api.html#nvim_buf_get_changedtick()
func (v *Nvim) BufferChangedTick(buffer Buffer) (changedtick int, err error) {
	err = v.call("nvim_buf_get_changedtick", &changedtick, buffer)
	return changedtick, err
}

// BufferChangedTick gets a changed tick of a buffer.
//
// See: [nvim_buf_get_changedtick()]
//
// [nvim_buf_get_changedtick()]: https://neovim.io/doc/user/api.html#nvim_buf_get_changedtick()
func (b *Batch) BufferChangedTick(buffer Buffer, changedtick *int) {
	b.call("nvim_buf_get_changedtick", changedtick, buffer)
}

// BufferKeymap gets a list of buffer-local mapping definitions.
//
// The mode short-name ("n", "i", "v", ...).
//
// See: [nvim_buf_get_keymap()]
//
// [nvim_buf_get_keymap()]: https://neovim.io/doc/user/api.html#nvim_buf_get_keymap()
func (v *Nvim) BufferKeyMap(buffer Buffer, mode string) ([]*Mapping, error) {
	var result []*Mapping
	err := v.call("nvim_buf_get_keymap", &result, buffer, mode)
	return result, err
}

// BufferKeymap gets a list of buffer-local mapping definitions.
//
// The mode short-name ("n", "i", "v", ...).
//
// See: [nvim_buf_get_keymap()]
//
// [nvim_buf_get_keymap()]: https://neovim.io/doc/user/api.html#nvim_buf_get_keymap()
func (b *Batch) BufferKeyMap(buffer Buffer, mode string, result *[]*Mapping) {
	b.call("nvim_buf_get_keymap", result, buffer, mode)
}

// SetBufferKeyMap sets a buffer-local mapping for the given mode.
//
// See: [nvim_buf_set_keymap()]
//
// [nvim_buf_set_keymap()]: https://neovim.io/doc/user/api.html#nvim_buf_set_keymap()
func (v *Nvim) SetBufferKeyMap(buffer Buffer, mode string, lhs string, rhs string, opts map[string]bool) error {
	return v.call("nvim_buf_set_keymap", nil, buffer, mode, lhs, rhs, opts)
}

// SetBufferKeyMap sets a buffer-local mapping for the given mode.
//
// See: [nvim_buf_set_keymap()]
//
// [nvim_buf_set_keymap()]: https://neovim.io/doc/user/api.html#nvim_buf_set_keymap()
func (b *Batch) SetBufferKeyMap(buffer Buffer, mode string, lhs string, rhs string, opts map[string]bool) {
	b.call("nvim_buf_set_keymap", nil, buffer, mode, lhs, rhs, opts)
}

// DeleteBufferKeyMap unmaps a buffer-local mapping for the given mode.
//
// See: [nvim_buf_del_keymap()]
//
// [nvim_buf_del_keymap()]: https://neovim.io/doc/user/api.html#nvim_buf_del_keymap()
func (v *Nvim) DeleteBufferKeyMap(buffer Buffer, mode string, lhs string) error {
	return v.call("nvim_buf_del_keymap", nil, buffer, mode, lhs)
}

// DeleteBufferKeyMap unmaps a buffer-local mapping for the given mode.
//
// See: [nvim_buf_del_keymap()]
//
// [nvim_buf_del_keymap()]: https://neovim.io/doc/user/api.html#nvim_buf_del_keymap()
func (b *Batch) DeleteBufferKeyMap(buffer Buffer, mode string, lhs string) {
	b.call("nvim_buf_del_keymap", nil, buffer, mode, lhs)
}

// SetBufferVar sets a buffer-scoped (b:) variable.
//
// See: [nvim_buf_set_var()]
//
// [nvim_buf_set_var()]: https://neovim.io/doc/user/api.html#nvim_buf_set_var()
func (v *Nvim) SetBufferVar(buffer Buffer, name string, value any) error {
	return v.call("nvim_buf_set_var", nil, buffer, name, value)
}

// SetBufferVar sets a buffer-scoped (b:) variable.
//
// See: [nvim_buf_set_var()]
//
// [nvim_buf_set_var()]: https://neovim.io/doc/user/api.html#nvim_buf_set_var()
func (b *Batch) SetBufferVar(buffer Buffer, name string, value any) {
	b.call("nvim_buf_set_var", nil, buffer, name, value)
}

// DeleteBufferVar removes a buffer-scoped (b:) variable.
//
// See: [nvim_buf_del_var()]
//
// [nvim_buf_del_var()]: https://neovim.io/doc/user/api.html#nvim_buf_del_var()
func (v *Nvim) DeleteBufferVar(buffer Buffer, name string) error {
	return v.call("nvim_buf_del_var", nil, buffer, name)
}

// DeleteBufferVar removes a buffer-scoped (b:) variable.
//
// See: [nvim_buf_del_var()]
//
// [nvim_buf_del_var()]: https://neovim.io/doc/user/api.html#nvim_buf_del_var()
func (b *Batch) DeleteBufferVar(buffer Buffer, name string) {
	b.call("nvim_buf_del_var", nil, buffer, name)
}

// BufferName gets the full file name for the buffer.
//
// See: [nvim_buf_get_name()]
//
// [nvim_buf_get_name()]: https://neovim.io/doc/user/api.html#nvim_buf_get_name()
func (v *Nvim) BufferName(buffer Buffer) (name string, err error) {
	err = v.call("nvim_buf_get_name", &name, buffer)
	return name, err
}

// BufferName gets the full file name for the buffer.
//
// See: [nvim_buf_get_name()]
//
// [nvim_buf_get_name()]: https://neovim.io/doc/user/api.html#nvim_buf_get_name()
func (b *Batch) BufferName(buffer Buffer, name *string) {
	b.call("nvim_buf_get_name", name, buffer)
}

// SetBufferName sets the full file name for a buffer.
//
// See: [nvim_buf_set_name()]
//
// [nvim_buf_set_name()]: https://neovim.io/doc/user/api.html#nvim_buf_set_name()
func (v *Nvim) SetBufferName(buffer Buffer, name string) error {
	return v.call("nvim_buf_set_name", nil, buffer, name)
}

// SetBufferName sets the full file name for a buffer.
//
// See: [nvim_buf_set_name()]
//
// [nvim_buf_set_name()]: https://neovim.io/doc/user/api.html#nvim_buf_set_name()
func (b *Batch) SetBufferName(buffer Buffer, name string) {
	b.call("nvim_buf_set_name", nil, buffer, name)
}

// IsBufferLoaded checks if a buffer is valid and loaded.
//
// See |help api-buffer| for more info about unloaded buffers.
//
// See: [nvim_buf_is_loaded()]
//
// [nvim_buf_is_loaded()]: https://neovim.io/doc/user/api.html#nvim_buf_is_loaded()
func (v *Nvim) IsBufferLoaded(buffer Buffer) (loaded bool, err error) {
	err = v.call("nvim_buf_is_loaded", &loaded, buffer)
	return loaded, err
}

// IsBufferLoaded checks if a buffer is valid and loaded.
//
// See |help api-buffer| for more info about unloaded buffers.
//
// See: [nvim_buf_is_loaded()]
//
// [nvim_buf_is_loaded()]: https://neovim.io/doc/user/api.html#nvim_buf_is_loaded()
func (b *Batch) IsBufferLoaded(buffer Buffer, loaded *bool) {
	b.call("nvim_buf_is_loaded", loaded, buffer)
}

// DeleteBuffer deletes the buffer.
// See
//
//	:help :bwipeout
//
// The opts args is optional parameters.
//
//	force
//
// Force deletion and ignore unsaved changes. bool type.
//
//	unload
//
// Unloaded only, do not delete. See |help :bunload|. bool type.
//
// See: [nvim_buf_delete()]
//
// [nvim_buf_delete()]: https://neovim.io/doc/user/api.html#nvim_buf_delete()
func (v *Nvim) DeleteBuffer(buffer Buffer, opts map[string]bool) error {
	return v.call("nvim_buf_delete", nil, buffer, opts)
}

// DeleteBuffer deletes the buffer.
// See
//
//	:help :bwipeout
//
// The opts args is optional parameters.
//
//	force
//
// Force deletion and ignore unsaved changes. bool type.
//
//	unload
//
// Unloaded only, do not delete. See |help :bunload|. bool type.
//
// See: [nvim_buf_delete()]
//
// [nvim_buf_delete()]: https://neovim.io/doc/user/api.html#nvim_buf_delete()
func (b *Batch) DeleteBuffer(buffer Buffer, opts map[string]bool) {
	b.call("nvim_buf_delete", nil, buffer, opts)
}

// IsBufferValid returns whether the buffer is valid.
//
// Note: Even if a buffer is valid it may have been unloaded.
// See |help api-buffer| for more info about unloaded buffers.
//
// See: [nvim_buf_is_valid()]
//
// [nvim_buf_is_valid()]: https://neovim.io/doc/user/api.html#nvim_buf_is_valid()
func (v *Nvim) IsBufferValid(buffer Buffer) (valied bool, err error) {
	err = v.call("nvim_buf_is_valid", &valied, buffer)
	return valied, err
}

// IsBufferValid returns whether the buffer is valid.
//
// Note: Even if a buffer is valid it may have been unloaded.
// See |help api-buffer| for more info about unloaded buffers.
//
// See: [nvim_buf_is_valid()]
//
// [nvim_buf_is_valid()]: https://neovim.io/doc/user/api.html#nvim_buf_is_valid()
func (b *Batch) IsBufferValid(buffer Buffer, valied *bool) {
	b.call("nvim_buf_is_valid", valied, buffer)
}

// DeleteBufferMark deletes a named mark in the buffer.
// See |help mark-motions|.
//
// See: [nvim_buf_del_mark()]
//
// [nvim_buf_del_mark()]: https://neovim.io/doc/user/api.html#nvim_buf_del_mark()
func (v *Nvim) DeleteBufferMark(buffer Buffer, name string) (deleted bool, err error) {
	err = v.call("nvim_buf_del_mark", &deleted, buffer, name)
	return deleted, err
}

// DeleteBufferMark deletes a named mark in the buffer.
// See |help mark-motions|.
//
// See: [nvim_buf_del_mark()]
//
// [nvim_buf_del_mark()]: https://neovim.io/doc/user/api.html#nvim_buf_del_mark()
func (b *Batch) DeleteBufferMark(buffer Buffer, name string, deleted *bool) {
	b.call("nvim_buf_del_mark", deleted, buffer, name)
}

// SetBufferMark sets a named mark in the given buffer, all marks are allowed
// file/uppercase, visual, last change, etc.
// See |help mark-motions|.
//
// line and col are (1,0)-indexed.
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_buf_set_mark()]
//
// [nvim_buf_set_mark()]: https://neovim.io/doc/user/api.html#nvim_buf_set_mark()
func (v *Nvim) SetBufferMark(buffer Buffer, name string, line int, col int, opts map[string]any) (set bool, err error) {
	err = v.call("nvim_buf_set_mark", &set, buffer, name, line, col, opts)
	return set, err
}

// SetBufferMark sets a named mark in the given buffer, all marks are allowed
// file/uppercase, visual, last change, etc.
// See |help mark-motions|.
//
// line and col are (1,0)-indexed.
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_buf_set_mark()]
//
// [nvim_buf_set_mark()]: https://neovim.io/doc/user/api.html#nvim_buf_set_mark()
func (b *Batch) SetBufferMark(buffer Buffer, name string, line int, col int, opts map[string]any, set *bool) {
	b.call("nvim_buf_set_mark", set, buffer, name, line, col, opts)
}

// BufferMark return a tuple (row,col) representing the position of the named mark.
//
// Marks are (1,0)-indexed.
//
// See: [nvim_buf_get_mark()]
//
// [nvim_buf_get_mark()]: https://neovim.io/doc/user/api.html#nvim_buf_get_mark()
func (v *Nvim) BufferMark(buffer Buffer, name string) (pos [2]int, err error) {
	err = v.call("nvim_buf_get_mark", &pos, buffer, name)
	return pos, err
}

// BufferMark return a tuple (row,col) representing the position of the named mark.
//
// Marks are (1,0)-indexed.
//
// See: [nvim_buf_get_mark()]
//
// [nvim_buf_get_mark()]: https://neovim.io/doc/user/api.html#nvim_buf_get_mark()
func (b *Batch) BufferMark(buffer Buffer, name string, pos *[2]int) {
	b.call("nvim_buf_get_mark", pos, buffer, name)
}

// ParseCmd parse command line.
//
// Doesn't check the validity of command arguments.
//
// str is command line string to parse. Cannot contain "\n".
//
// opts is optional parameters. Reserved for future use.
//
// Return dictionary containing command information, with these keys:
//
//	cmd: (string)
//
// Command name
//
//	range: ([]int)
//
// Command <range>. Can have 0-2 elements depending on how many items the range contains.
// Has no elements if command doesn't accept a range or if no range was specified,
// one element if only a single range item was specified and two elements if both range items were specified.
//
//	count: (int)
//
// Any |<count>| that was supplied to the command. -1 if command cannot take a count.
//
//	reg: (int)
//
// The optional command |<register>|, if specified. Empty string if not specified or if command cannot take a register.
//
//	bang: (bool)
//
// Whether command contains a |<bang>| (!) modifier.
//
//	args: ([]string)
//
// Command arguments.
//
//	addr: (string)
//
// Value of |:command-addr|. Uses short name.
//
//	nargs: (string)
//
// Value of |:command-nargs|.
//
//	nextcmd: (string)
//
// Next command if there are multiple commands separated by a |:bar|. Empty if there isn't a next command.
//
//	magic: (struct)
//
// Which characters have special meaning in the command arguments.
//
//	magic.file: (bool)
//
// The command expands filenames. Which means characters such as "%", "#" and wildcards are expanded.
//
//	magic.bar: (bool)
//
// The "|" character is treated as a command separator and the double quote character (\") is treated as the start of a comment.
//
//	mods: (struct)
//
// mods
//
//	mods.filter: (struct)
//
// |:filter|.
//
//	mods.filter.pattern: (string)
//
// Filter pattern. Empty string if there is no filter.
//
//	mods.filter.force: (bool)
//
// Whether filter is inverted or not.
//
//	mods.silent: (bool)
//
// silent
//
//	mods.emsg_silent: (bool)
//
// emsg_silent
//
//	mods.unsilent: (bool)
//
// unsilent
//
//	mods.sandbox: (bool)
//
// sandbox
//
//	mods.noautocmd: (bool)
//
// noautocmd
//
//	mods.browse: (bool)
//
// browse
//
//	mods.confirm: (bool)
//
// confirm
//
//	mods.hide: (bool)
//
// hide
//
//	mods.horizontal: (bool)
//
// horizontal
//
//	mods.keepalt: (bool)
//
// keepalt
//
//	mods.keepjumps: (bool)
//
// keepjumps
//
//	mods.keepmarks: (bool)
//
// keepmarks
//
//	mods.keeppatterns: (bool)
//
// keeppatterns
//
//	mods.lockmarks: (bool)
//
// lockmarks
//
//	mods.noswapfile: (bool)
//
// noswapfile
//
//	mods.tab: (int)
//
// -1 when omitted.
//
//	verbose: (int)
//
// -1 when omitted.
//
//	vertical: (bool)
//
// vertical
//
//	split: (string)
//
// Split modifier string, is an empty string when there's no split modifier. If there is a split modifier it can be one of:
//
//	aboveleft
//	belowright
//	topleft
//	botright
//
// See: [nvim_parse_cmd()]
//
// [nvim_parse_cmd()]: https://neovim.io/doc/user/api.html#nvim_parse_cmd()
func (v *Nvim) ParseCmd(str string, opts map[string]any) (cmd *Cmd, err error) {
	var result Cmd
	err = v.call("nvim_parse_cmd", &result, str, opts)
	return &result, err
}

// ParseCmd parse command line.
//
// Doesn't check the validity of command arguments.
//
// str is command line string to parse. Cannot contain "\n".
//
// opts is optional parameters. Reserved for future use.
//
// Return dictionary containing command information, with these keys:
//
//	cmd: (string)
//
// Command name
//
//	range: ([]int)
//
// Command <range>. Can have 0-2 elements depending on how many items the range contains.
// Has no elements if command doesn't accept a range or if no range was specified,
// one element if only a single range item was specified and two elements if both range items were specified.
//
//	count: (int)
//
// Any |<count>| that was supplied to the command. -1 if command cannot take a count.
//
//	reg: (int)
//
// The optional command |<register>|, if specified. Empty string if not specified or if command cannot take a register.
//
//	bang: (bool)
//
// Whether command contains a |<bang>| (!) modifier.
//
//	args: ([]string)
//
// Command arguments.
//
//	addr: (string)
//
// Value of |:command-addr|. Uses short name.
//
//	nargs: (string)
//
// Value of |:command-nargs|.
//
//	nextcmd: (string)
//
// Next command if there are multiple commands separated by a |:bar|. Empty if there isn't a next command.
//
//	magic: (struct)
//
// Which characters have special meaning in the command arguments.
//
//	magic.file: (bool)
//
// The command expands filenames. Which means characters such as "%", "#" and wildcards are expanded.
//
//	magic.bar: (bool)
//
// The "|" character is treated as a command separator and the double quote character (\") is treated as the start of a comment.
//
//	mods: (struct)
//
// mods
//
//	mods.filter: (struct)
//
// |:filter|.
//
//	mods.filter.pattern: (string)
//
// Filter pattern. Empty string if there is no filter.
//
//	mods.filter.force: (bool)
//
// Whether filter is inverted or not.
//
//	mods.silent: (bool)
//
// silent
//
//	mods.emsg_silent: (bool)
//
// emsg_silent
//
//	mods.unsilent: (bool)
//
// unsilent
//
//	mods.sandbox: (bool)
//
// sandbox
//
//	mods.noautocmd: (bool)
//
// noautocmd
//
//	mods.browse: (bool)
//
// browse
//
//	mods.confirm: (bool)
//
// confirm
//
//	mods.hide: (bool)
//
// hide
//
//	mods.horizontal: (bool)
//
// horizontal
//
//	mods.keepalt: (bool)
//
// keepalt
//
//	mods.keepjumps: (bool)
//
// keepjumps
//
//	mods.keepmarks: (bool)
//
// keepmarks
//
//	mods.keeppatterns: (bool)
//
// keeppatterns
//
//	mods.lockmarks: (bool)
//
// lockmarks
//
//	mods.noswapfile: (bool)
//
// noswapfile
//
//	mods.tab: (int)
//
// -1 when omitted.
//
//	verbose: (int)
//
// -1 when omitted.
//
//	vertical: (bool)
//
// vertical
//
//	split: (string)
//
// Split modifier string, is an empty string when there's no split modifier. If there is a split modifier it can be one of:
//
//	aboveleft
//	belowright
//	topleft
//	botright
//
// See: [nvim_parse_cmd()]
//
// [nvim_parse_cmd()]: https://neovim.io/doc/user/api.html#nvim_parse_cmd()
func (b *Batch) ParseCmd(str string, opts map[string]any, cmd *Cmd) {
	b.call("nvim_parse_cmd", cmd, str, opts)
}

// Cmd executes an Ex command.
//
// Unlike Command() this command takes a structured Dictionary instead of a String. This
// allows for easier construction and manipulation of an Ex command. This also allows for things
// such as having spaces inside a command argument, expanding filenames in a command that otherwise
// doesn't expand filenames, etc.
//
// On execution error: fails with VimL error, updates v:errmsg.
// See Exec() and Command().
//
// cmd is the command to execute. Must be a Dictionary that can contain the same values
// as the return value of ParseCmd except "addr", "nargs" and "nextcmd" which are ignored if provided.
// All values except for "cmd" are optional.
//
// opts is the optional parameters.
//
//	output: (boolean, default false)
//
// Whether to return command output.
//
// See: [nvim_cmd()]
//
// [nvim_cmd()]: https://neovim.io/doc/user/api.html#nvim_cmd()
func (v *Nvim) Cmd(cmd *Cmd, opts map[string]bool) (output string, err error) {
	err = v.call("nvim_cmd", &output, cmd, opts)
	return output, err
}

// Cmd executes an Ex command.
//
// Unlike Command() this command takes a structured Dictionary instead of a String. This
// allows for easier construction and manipulation of an Ex command. This also allows for things
// such as having spaces inside a command argument, expanding filenames in a command that otherwise
// doesn't expand filenames, etc.
//
// On execution error: fails with VimL error, updates v:errmsg.
// See Exec() and Command().
//
// cmd is the command to execute. Must be a Dictionary that can contain the same values
// as the return value of ParseCmd except "addr", "nargs" and "nextcmd" which are ignored if provided.
// All values except for "cmd" are optional.
//
// opts is the optional parameters.
//
//	output: (boolean, default false)
//
// Whether to return command output.
//
// See: [nvim_cmd()]
//
// [nvim_cmd()]: https://neovim.io/doc/user/api.html#nvim_cmd()
func (b *Batch) Cmd(cmd *Cmd, opts map[string]bool, output *string) {
	b.call("nvim_cmd", output, cmd, opts)
}

// CreateUserCommand create a new user command.
//
// name is name of the new user command. Must begin with an uppercase letter.
//
// command is replacement command to execute when this user command is executed.
// When called from Lua, the command can also be a Lua function.
//
// opts is optional command attributes. See |command-attributes| for more details.
//
// To use boolean attributes (such as |:command-bang| or |:command-bar|) set the value to "true".
// In addition to the string options listed in |:command-complete|,
// the "complete" key also accepts a Lua function which works like the "customlist" completion mode |:command-completion-customlist|.
//
//	desc (string)
//
// Used for listing the command when a Lua function is used for {command}.
//
//	force (bool, default true)
//
// Override any previous definition.
//
// See: [nvim_create_user_command()]
//
// [nvim_create_user_command()]: https://neovim.io/doc/user/api.html#nvim_create_user_command()
func (v *Nvim) CreateUserCommand(name string, command UserCommand, opts map[string]any) error {
	return v.call("nvim_create_user_command", nil, name, command, opts)
}

// CreateUserCommand create a new user command.
//
// name is name of the new user command. Must begin with an uppercase letter.
//
// command is replacement command to execute when this user command is executed.
// When called from Lua, the command can also be a Lua function.
//
// opts is optional command attributes. See |command-attributes| for more details.
//
// To use boolean attributes (such as |:command-bang| or |:command-bar|) set the value to "true".
// In addition to the string options listed in |:command-complete|,
// the "complete" key also accepts a Lua function which works like the "customlist" completion mode |:command-completion-customlist|.
//
//	desc (string)
//
// Used for listing the command when a Lua function is used for {command}.
//
//	force (bool, default true)
//
// Override any previous definition.
//
// See: [nvim_create_user_command()]
//
// [nvim_create_user_command()]: https://neovim.io/doc/user/api.html#nvim_create_user_command()
func (b *Batch) CreateUserCommand(name string, command UserCommand, opts map[string]any) {
	b.call("nvim_create_user_command", nil, name, command, opts)
}

// DeleteUserCommand delete a user-defined command.
//
// See: [nvim_del_user_command()]
//
// [nvim_del_user_command()]: https://neovim.io/doc/user/api.html#nvim_del_user_command()
func (v *Nvim) DeleteUserCommand(name string) error {
	return v.call("nvim_del_user_command", nil, name)
}

// DeleteUserCommand delete a user-defined command.
//
// See: [nvim_del_user_command()]
//
// [nvim_del_user_command()]: https://neovim.io/doc/user/api.html#nvim_del_user_command()
func (b *Batch) DeleteUserCommand(name string) {
	b.call("nvim_del_user_command", nil, name)
}

// CreateBufferUserCommand create a new user command |user-commands| in the given buffer.
//
// Only commands created with |:command-buffer| or this function can be deleted with this function.
//
// See: [nvim_buf_create_user_command()]
//
// [nvim_buf_create_user_command()]: https://neovim.io/doc/user/api.html#nvim_buf_create_user_command()
func (v *Nvim) CreateBufferUserCommand(buffer Buffer, name string, command UserCommand, opts map[string]any) error {
	return v.call("nvim_buf_create_user_command", nil, buffer, name, command, opts)
}

// CreateBufferUserCommand create a new user command |user-commands| in the given buffer.
//
// Only commands created with |:command-buffer| or this function can be deleted with this function.
//
// See: [nvim_buf_create_user_command()]
//
// [nvim_buf_create_user_command()]: https://neovim.io/doc/user/api.html#nvim_buf_create_user_command()
func (b *Batch) CreateBufferUserCommand(buffer Buffer, name string, command UserCommand, opts map[string]any) {
	b.call("nvim_buf_create_user_command", nil, buffer, name, command, opts)
}

// DeleteBufferUserCommand create a new user command |user-commands| in the given buffer.
//
// Only commands created with |:command-buffer| or this function can be deleted with this function.
//
// See: [nvim_buf_del_user_command()]
//
// [nvim_buf_del_user_command()]: https://neovim.io/doc/user/api.html#nvim_buf_del_user_command()
func (v *Nvim) DeleteBufferUserCommand(buffer Buffer, name string) error {
	return v.call("nvim_buf_del_user_command", nil, buffer, name)
}

// DeleteBufferUserCommand create a new user command |user-commands| in the given buffer.
//
// Only commands created with |:command-buffer| or this function can be deleted with this function.
//
// See: [nvim_buf_del_user_command()]
//
// [nvim_buf_del_user_command()]: https://neovim.io/doc/user/api.html#nvim_buf_del_user_command()
func (b *Batch) DeleteBufferUserCommand(buffer Buffer, name string) {
	b.call("nvim_buf_del_user_command", nil, buffer, name)
}

// Commands gets a map of global (non-buffer-local) Ex commands.
// Currently only user-commands are supported, not builtin Ex commands.
//
// opts is optional parameters. Currently only supports:
//
//	{"builtin":false}
//
// See: [nvim_get_commands()]
//
// [nvim_get_commands()]: https://neovim.io/doc/user/api.html#nvim_get_commands()
func (v *Nvim) Commands(opts map[string]any) (commands map[string]*Command, err error) {
	err = v.call("nvim_get_commands", &commands, opts)
	return commands, err
}

// Commands gets a map of global (non-buffer-local) Ex commands.
// Currently only user-commands are supported, not builtin Ex commands.
//
// opts is optional parameters. Currently only supports:
//
//	{"builtin":false}
//
// See: [nvim_get_commands()]
//
// [nvim_get_commands()]: https://neovim.io/doc/user/api.html#nvim_get_commands()
func (b *Batch) Commands(opts map[string]any, commands *map[string]*Command) {
	b.call("nvim_get_commands", commands, opts)
}

// BufferCommands gets a map of buffer-local user-commands.
//
// opts is optional parameters. Currently not used.
//
// See: [nvim_buf_get_commands()]
//
// [nvim_buf_get_commands()]: https://neovim.io/doc/user/api.html#nvim_buf_get_commands()
func (v *Nvim) BufferCommands(buffer Buffer, opts map[string]any) (map[string]*Command, error) {
	var result map[string]*Command
	err := v.call("nvim_buf_get_commands", &result, buffer, opts)
	return result, err
}

// BufferCommands gets a map of buffer-local user-commands.
//
// opts is optional parameters. Currently not used.
//
// See: [nvim_buf_get_commands()]
//
// [nvim_buf_get_commands()]: https://neovim.io/doc/user/api.html#nvim_buf_get_commands()
func (b *Batch) BufferCommands(buffer Buffer, opts map[string]any, result *map[string]*Command) {
	b.call("nvim_buf_get_commands", result, buffer, opts)
}

// TabpageWindows gets the windows in a tabpage.
//
// See: [nvim_tabpage_list_wins()]
//
// [nvim_tabpage_list_wins()]: https://neovim.io/doc/user/api.html#nvim_tabpage_list_wins()
func (v *Nvim) TabpageWindows(tabpage Tabpage) (windows []Window, err error) {
	err = v.call("nvim_tabpage_list_wins", &windows, tabpage)
	return windows, err
}

// TabpageWindows gets the windows in a tabpage.
//
// See: [nvim_tabpage_list_wins()]
//
// [nvim_tabpage_list_wins()]: https://neovim.io/doc/user/api.html#nvim_tabpage_list_wins()
func (b *Batch) TabpageWindows(tabpage Tabpage, windows *[]Window) {
	b.call("nvim_tabpage_list_wins", windows, tabpage)
}

// TabpageVar gets a tab-scoped (t:) variable.
//
// See: [nvim_tabpage_get_var()]
//
// [nvim_tabpage_get_var()]: https://neovim.io/doc/user/api.html#nvim_tabpage_get_var()
func (v *Nvim) TabpageVar(tabpage Tabpage, name string, result any) error {
	return v.call("nvim_tabpage_get_var", result, tabpage, name)
}

// TabpageVar gets a tab-scoped (t:) variable.
//
// See: [nvim_tabpage_get_var()]
//
// [nvim_tabpage_get_var()]: https://neovim.io/doc/user/api.html#nvim_tabpage_get_var()
func (b *Batch) TabpageVar(tabpage Tabpage, name string, result any) {
	b.call("nvim_tabpage_get_var", &result, tabpage, name)
}

// SetTabpageVar sets a tab-scoped (t:) variable.
//
// See: [nvim_tabpage_set_var()]
//
// [nvim_tabpage_set_var()]: https://neovim.io/doc/user/api.html#nvim_tabpage_set_var()
func (v *Nvim) SetTabpageVar(tabpage Tabpage, name string, value any) error {
	return v.call("nvim_tabpage_set_var", nil, tabpage, name, value)
}

// SetTabpageVar sets a tab-scoped (t:) variable.
//
// See: [nvim_tabpage_set_var()]
//
// [nvim_tabpage_set_var()]: https://neovim.io/doc/user/api.html#nvim_tabpage_set_var()
func (b *Batch) SetTabpageVar(tabpage Tabpage, name string, value any) {
	b.call("nvim_tabpage_set_var", nil, tabpage, name, value)
}

// DeleteTabpageVar removes a tab-scoped (t:) variable.
//
// See: [nvim_tabpage_del_var()]
//
// [nvim_tabpage_del_var()]: https://neovim.io/doc/user/api.html#nvim_tabpage_del_var()
func (v *Nvim) DeleteTabpageVar(tabpage Tabpage, name string) error {
	return v.call("nvim_tabpage_del_var", nil, tabpage, name)
}

// DeleteTabpageVar removes a tab-scoped (t:) variable.
//
// See: [nvim_tabpage_del_var()]
//
// [nvim_tabpage_del_var()]: https://neovim.io/doc/user/api.html#nvim_tabpage_del_var()
func (b *Batch) DeleteTabpageVar(tabpage Tabpage, name string) {
	b.call("nvim_tabpage_del_var", nil, tabpage, name)
}

// TabpageWindow gets the current window in a tabpage.
//
// See: [nvim_tabpage_get_win()]
//
// [nvim_tabpage_get_win()]: https://neovim.io/doc/user/api.html#nvim_tabpage_get_win()
func (v *Nvim) TabpageWindow(tabpage Tabpage) (Window, error) {
	var result Window
	err := v.call("nvim_tabpage_get_win", &result, tabpage)
	return result, err
}

// TabpageWindow gets the current window in a tabpage.
//
// See: [nvim_tabpage_get_win()]
//
// [nvim_tabpage_get_win()]: https://neovim.io/doc/user/api.html#nvim_tabpage_get_win()
func (b *Batch) TabpageWindow(tabpage Tabpage, result *Window) {
	b.call("nvim_tabpage_get_win", result, tabpage)
}

// TabpageNumber gets the tabpage number.
//
// See: [nvim_tabpage_get_number()]
//
// [nvim_tabpage_get_number()]: https://neovim.io/doc/user/api.html#nvim_tabpage_get_number()
func (v *Nvim) TabpageNumber(tabpage Tabpage) (number int, err error) {
	err = v.call("nvim_tabpage_get_number", &number, tabpage)
	return number, err
}

// TabpageNumber gets the tabpage number.
//
// See: [nvim_tabpage_get_number()]
//
// [nvim_tabpage_get_number()]: https://neovim.io/doc/user/api.html#nvim_tabpage_get_number()
func (b *Batch) TabpageNumber(tabpage Tabpage, number *int) {
	b.call("nvim_tabpage_get_number", number, tabpage)
}

// IsTabpageValid checks if a tabpage is valid.
//
// See: [nvim_tabpage_is_valid()]
//
// [nvim_tabpage_is_valid()]: https://neovim.io/doc/user/api.html#nvim_tabpage_is_valid()
func (v *Nvim) IsTabpageValid(tabpage Tabpage) (valid bool, err error) {
	err = v.call("nvim_tabpage_is_valid", &valid, tabpage)
	return valid, err
}

// IsTabpageValid checks if a tabpage is valid.
//
// See: [nvim_tabpage_is_valid()]
//
// [nvim_tabpage_is_valid()]: https://neovim.io/doc/user/api.html#nvim_tabpage_is_valid()
func (b *Batch) IsTabpageValid(tabpage Tabpage, valid *bool) {
	b.call("nvim_tabpage_is_valid", valid, tabpage)
}

// CreateNamespace creates a new namespace, or gets an existing one.
//
// Namespaces are used for buffer highlights and virtual text, see
// AddBufferHighlight and SetBufferVirtualText.
//
// Namespaces can be named or anonymous. If "name" matches an existing namespace,
// the associated id is returned. If "name" is an empty string a new, anonymous
// namespace is created.
//
// The returns the namespace ID.
//
// See: [nvim_create_namespace()]
//
// [nvim_create_namespace()]: https://neovim.io/doc/user/api.html#nvim_create_namespace()
func (v *Nvim) CreateNamespace(name string) (nsID int, err error) {
	err = v.call("nvim_create_namespace", &nsID, name)
	return nsID, err
}

// CreateNamespace creates a new namespace, or gets an existing one.
//
// Namespaces are used for buffer highlights and virtual text, see
// AddBufferHighlight and SetBufferVirtualText.
//
// Namespaces can be named or anonymous. If "name" matches an existing namespace,
// the associated id is returned. If "name" is an empty string a new, anonymous
// namespace is created.
//
// The returns the namespace ID.
//
// See: [nvim_create_namespace()]
//
// [nvim_create_namespace()]: https://neovim.io/doc/user/api.html#nvim_create_namespace()
func (b *Batch) CreateNamespace(name string, nsID *int) {
	b.call("nvim_create_namespace", nsID, name)
}

// BufferExtmarkByID beturns position for a given extmark id.
//
// opts is optional parameters.
//
//	details
//
// Whether to include the details dict. bool type.
//
// See: [nvim_buf_get_extmark_by_id()]
//
// [nvim_buf_get_extmark_by_id()]: https://neovim.io/doc/user/api.html#nvim_buf_get_extmark_by_id()
func (v *Nvim) BufferExtmarkByID(buffer Buffer, nsID int, id int, opt map[string]any) (pos []int, err error) {
	err = v.call("nvim_buf_get_extmark_by_id", &pos, buffer, nsID, id, opt)
	return pos, err
}

// BufferExtmarkByID beturns position for a given extmark id.
//
// opts is optional parameters.
//
//	details
//
// Whether to include the details dict. bool type.
//
// See: [nvim_buf_get_extmark_by_id()]
//
// [nvim_buf_get_extmark_by_id()]: https://neovim.io/doc/user/api.html#nvim_buf_get_extmark_by_id()
func (b *Batch) BufferExtmarkByID(buffer Buffer, nsID int, id int, opt map[string]any, pos *[]int) {
	b.call("nvim_buf_get_extmark_by_id", pos, buffer, nsID, id, opt)
}

// BufferExtmarks gets extmarks in "traversal order" from a |charwise| region defined by
// buffer positions (inclusive, 0-indexed).
//
// Region can be given as (row,col) tuples, or valid extmark ids (whose
// positions define the bounds).
// 0 and -1 are understood as (0,0) and (-1,-1) respectively, thus the following are equivalent:
//
//	BufferExtmarks(0, myNS, 0, -1, {})
//	BufferExtmarks(0, myNS, [0,0], [-1,-1], {})
//
// If end arg is less than start arg, traversal works backwards.
// It useful with limit arg, to get the first marks prior to a given position.
//
// The start and end args is start or end of range, given as (row, col), or
// valid extmark id whose position defines the bound.
//
// opts is optional parameters.
//
//	limit
//
// Maximum number of marks to return. int type.
//
//	details
//
// Whether to include the details dict. bool type.
//
// See: [nvim_buf_get_extmarks()]
//
// [nvim_buf_get_extmarks()]: https://neovim.io/doc/user/api.html#nvim_buf_get_extmarks()
func (v *Nvim) BufferExtmarks(buffer Buffer, nsID int, start any, end any, opt map[string]any) (marks []ExtMark, err error) {
	err = v.call("nvim_buf_get_extmarks", &marks, buffer, nsID, start, end, opt)
	return marks, err
}

// BufferExtmarks gets extmarks in "traversal order" from a |charwise| region defined by
// buffer positions (inclusive, 0-indexed).
//
// Region can be given as (row,col) tuples, or valid extmark ids (whose
// positions define the bounds).
// 0 and -1 are understood as (0,0) and (-1,-1) respectively, thus the following are equivalent:
//
//	BufferExtmarks(0, myNS, 0, -1, {})
//	BufferExtmarks(0, myNS, [0,0], [-1,-1], {})
//
// If end arg is less than start arg, traversal works backwards.
// It useful with limit arg, to get the first marks prior to a given position.
//
// The start and end args is start or end of range, given as (row, col), or
// valid extmark id whose position defines the bound.
//
// opts is optional parameters.
//
//	limit
//
// Maximum number of marks to return. int type.
//
//	details
//
// Whether to include the details dict. bool type.
//
// See: [nvim_buf_get_extmarks()]
//
// [nvim_buf_get_extmarks()]: https://neovim.io/doc/user/api.html#nvim_buf_get_extmarks()
func (b *Batch) BufferExtmarks(buffer Buffer, nsID int, start any, end any, opt map[string]any, marks *[]ExtMark) {
	b.call("nvim_buf_get_extmarks", marks, buffer, nsID, start, end, opt)
}

// SetBufferExtmark creates or updates an extmark.
//
// To create a new extmark, pass id=0. The extmark id will be returned.
// To move an existing mark, pass its id.
//
// It is also allowed to create a new mark by passing in a previously unused
// id, but the caller must then keep track of existing and unused ids itself.
// (Useful over RPC, to avoid waiting for the return value.)
//
// Using the optional arguments, it is possible to use this to highlight
// a range of text, and also to associate virtual text to the mark.
//
// The opts arg is optional parameters.
//
//	id
//
// ID of the extmark to edit.
//
//	end_line
//
// Ending line of the mark, 0-based inclusive.
//
//	end_col
//
// Ending col of the mark, 0-based inclusive.
//
//	hl_group
//
// Name of the highlight group used to highlight this mark.
//
//	virt_text
//
// Virtual text to link to this mark.
//
//	virt_text_pos
//
// Positioning of virtual text.
// Possible values:
//
//	eol
//
// right after eol character (default)
//
//	overlay
//
// display over the specified column, without shifting the underlying text.
//
//	virt_text_win_col
//
// position the virtual text at a fixed window column (starting from the first text column)
//
//	virt_text_hide
//
// Hide the virtual text when the background text is selected or hidden due to horizontal scroll "nowrap".
//
//	hl_mode
//
// Control how highlights are combined with the highlights of the text. Currently only affects
// virt_text highlights, but might affect "hl_group" in later versions.
// Possible values:
//
//	replace
//
// only show the virt_text color. This is the default.
//
//	combine
//
// combine with background text color
//
//	blend
//
// blend with background text color.
//
//	hl_eol
//
// when true, for a multiline highlight covering the EOL of a line, continue the highlight for the rest
// of the screen line (just like for diff and cursorline highlight).
//
//	ephemeral
//
// For use with "nvim_set_decoration_provider" callbacks. The mark will only be used for the current redraw cycle,
// and not be permantently stored in the buffer.
//
//	right_gravity
//
// Boolean that indicates the direction the extmark will be shifted in when new text is
// inserted (true for right, false for left).  defaults to true.
//
//	end_right_gravity
//
// Boolean that indicates the direction the extmark end position (if it exists) will be
// shifted in when new text is inserted (true for right, false for left). Defaults to false.
//
//	priority
//
// A priority value for the highlight group. For example treesitter highlighting uses a value of 100.
//
// See: [nvim_buf_set_extmark()]
//
// [nvim_buf_set_extmark()]: https://neovim.io/doc/user/api.html#nvim_buf_set_extmark()
func (v *Nvim) SetBufferExtmark(buffer Buffer, nsID int, line int, col int, opts map[string]any) (id int, err error) {
	err = v.call("nvim_buf_set_extmark", &id, buffer, nsID, line, col, opts)
	return id, err
}

// SetBufferExtmark creates or updates an extmark.
//
// To create a new extmark, pass id=0. The extmark id will be returned.
// To move an existing mark, pass its id.
//
// It is also allowed to create a new mark by passing in a previously unused
// id, but the caller must then keep track of existing and unused ids itself.
// (Useful over RPC, to avoid waiting for the return value.)
//
// Using the optional arguments, it is possible to use this to highlight
// a range of text, and also to associate virtual text to the mark.
//
// The opts arg is optional parameters.
//
//	id
//
// ID of the extmark to edit.
//
//	end_line
//
// Ending line of the mark, 0-based inclusive.
//
//	end_col
//
// Ending col of the mark, 0-based inclusive.
//
//	hl_group
//
// Name of the highlight group used to highlight this mark.
//
//	virt_text
//
// Virtual text to link to this mark.
//
//	virt_text_pos
//
// Positioning of virtual text.
// Possible values:
//
//	eol
//
// right after eol character (default)
//
//	overlay
//
// display over the specified column, without shifting the underlying text.
//
//	virt_text_win_col
//
// position the virtual text at a fixed window column (starting from the first text column)
//
//	virt_text_hide
//
// Hide the virtual text when the background text is selected or hidden due to horizontal scroll "nowrap".
//
//	hl_mode
//
// Control how highlights are combined with the highlights of the text. Currently only affects
// virt_text highlights, but might affect "hl_group" in later versions.
// Possible values:
//
//	replace
//
// only show the virt_text color. This is the default.
//
//	combine
//
// combine with background text color
//
//	blend
//
// blend with background text color.
//
//	hl_eol
//
// when true, for a multiline highlight covering the EOL of a line, continue the highlight for the rest
// of the screen line (just like for diff and cursorline highlight).
//
//	ephemeral
//
// For use with "nvim_set_decoration_provider" callbacks. The mark will only be used for the current redraw cycle,
// and not be permantently stored in the buffer.
//
//	right_gravity
//
// Boolean that indicates the direction the extmark will be shifted in when new text is
// inserted (true for right, false for left).  defaults to true.
//
//	end_right_gravity
//
// Boolean that indicates the direction the extmark end position (if it exists) will be
// shifted in when new text is inserted (true for right, false for left). Defaults to false.
//
//	priority
//
// A priority value for the highlight group. For example treesitter highlighting uses a value of 100.
//
// See: [nvim_buf_set_extmark()]
//
// [nvim_buf_set_extmark()]: https://neovim.io/doc/user/api.html#nvim_buf_set_extmark()
func (b *Batch) SetBufferExtmark(buffer Buffer, nsID int, line int, col int, opts map[string]any, id *int) {
	b.call("nvim_buf_set_extmark", id, buffer, nsID, line, col, opts)
}

// DeleteBufferExtmark removes an extmark.
//
// THe returns whether the extmark was found.
//
// See: [nvim_buf_del_extmark()]
//
// [nvim_buf_del_extmark()]: https://neovim.io/doc/user/api.html#nvim_buf_del_extmark()
func (v *Nvim) DeleteBufferExtmark(buffer Buffer, nsID int, extmarkID int) (deleted bool, err error) {
	err = v.call("nvim_buf_del_extmark", &deleted, buffer, nsID, extmarkID)
	return deleted, err
}

// DeleteBufferExtmark removes an extmark.
//
// THe returns whether the extmark was found.
//
// See: [nvim_buf_del_extmark()]
//
// [nvim_buf_del_extmark()]: https://neovim.io/doc/user/api.html#nvim_buf_del_extmark()
func (b *Batch) DeleteBufferExtmark(buffer Buffer, nsID int, extmarkID int, deleted *bool) {
	b.call("nvim_buf_del_extmark", deleted, buffer, nsID, extmarkID)
}

// AddBufferHighlight adds a highlight to buffer.
//
// IT useful for plugins that dynamically generate highlights to a buffer like a semantic highlighter or linter.
//
// The function adds a single highlight to a buffer.
// Unlike |matchaddpos()| vim function, highlights follow changes to line numbering as lines are
// inserted/removed above the highlighted line, like signs and marks do.
//
// Namespaces are used for batch deletion/updating of a set of highlights.
// To create a namespace, use CreateNamespace which returns a namespace id.
// Pass it in to this function as nsID to add highlights to the namespace.
// All highlights in the same namespace can then be cleared with single call to ClearBufferNamespace.
// If the highlight never will be deleted by an API call, pass nsID = -1.
//
// As a shorthand, "srcID = 0" can be used to create a new namespace for the
// highlight, the allocated id is then returned.
//
// If hlGroup arg is the empty string, no highlight is added, but a new `nsID` is still returned.
// This is supported for backwards compatibility, new code should use CreateNamespaceto create a new empty namespace.
//
// See: [nvim_buf_add_highlight()]
//
// [nvim_buf_add_highlight()]: https://neovim.io/doc/user/api.html#nvim_buf_add_highlight()
func (v *Nvim) AddBufferHighlight(buffer Buffer, srcID int, hlGroup string, line int, startCol int, endCol int) (id int, err error) {
	err = v.call("nvim_buf_add_highlight", &id, buffer, srcID, hlGroup, line, startCol, endCol)
	return id, err
}

// AddBufferHighlight adds a highlight to buffer.
//
// IT useful for plugins that dynamically generate highlights to a buffer like a semantic highlighter or linter.
//
// The function adds a single highlight to a buffer.
// Unlike |matchaddpos()| vim function, highlights follow changes to line numbering as lines are
// inserted/removed above the highlighted line, like signs and marks do.
//
// Namespaces are used for batch deletion/updating of a set of highlights.
// To create a namespace, use CreateNamespace which returns a namespace id.
// Pass it in to this function as nsID to add highlights to the namespace.
// All highlights in the same namespace can then be cleared with single call to ClearBufferNamespace.
// If the highlight never will be deleted by an API call, pass nsID = -1.
//
// As a shorthand, "srcID = 0" can be used to create a new namespace for the
// highlight, the allocated id is then returned.
//
// If hlGroup arg is the empty string, no highlight is added, but a new `nsID` is still returned.
// This is supported for backwards compatibility, new code should use CreateNamespaceto create a new empty namespace.
//
// See: [nvim_buf_add_highlight()]
//
// [nvim_buf_add_highlight()]: https://neovim.io/doc/user/api.html#nvim_buf_add_highlight()
func (b *Batch) AddBufferHighlight(buffer Buffer, srcID int, hlGroup string, line int, startCol int, endCol int, id *int) {
	b.call("nvim_buf_add_highlight", id, buffer, srcID, hlGroup, line, startCol, endCol)
}

// ClearBufferNamespace clears namespaced objects (highlights, extmarks, virtual text) from a region.
// Lines are 0-indexed.
//
// To clear the namespace in the entire buffer, specify line_start=0 and line_end=-1.
//
// See: [nvim_buf_clear_namespace()]
//
// [nvim_buf_clear_namespace()]: https://neovim.io/doc/user/api.html#nvim_buf_clear_namespace()
func (v *Nvim) ClearBufferNamespace(buffer Buffer, nsID int, lineStart int, lineEnd int) error {
	return v.call("nvim_buf_clear_namespace", nil, buffer, nsID, lineStart, lineEnd)
}

// ClearBufferNamespace clears namespaced objects (highlights, extmarks, virtual text) from a region.
// Lines are 0-indexed.
//
// To clear the namespace in the entire buffer, specify line_start=0 and line_end=-1.
//
// See: [nvim_buf_clear_namespace()]
//
// [nvim_buf_clear_namespace()]: https://neovim.io/doc/user/api.html#nvim_buf_clear_namespace()
func (b *Batch) ClearBufferNamespace(buffer Buffer, nsID int, lineStart int, lineEnd int) {
	b.call("nvim_buf_clear_namespace", nil, buffer, nsID, lineStart, lineEnd)
}

// OptionValue gets the value of an option.
//
// The behavior of this function matches that of |:set|: the local value of an option is returned if it exists; otherwise,
// the global value is returned.
// Local values always correspond to the current buffer or window.
//
// To get a buffer-local or window-local option for a specific buffer or window, use BufferOption() or WindowOption().
//
// name is the option name.
//
// opts is the Optional parameters.
//
//	scope
//
// Analogous to |:setglobal| and |:setlocal|, respectively.
//
// See: [nvim_get_option_value()]
//
// [nvim_get_option_value()]: https://neovim.io/doc/user/api.html#nvim_get_option_value()
func (v *Nvim) OptionValue(name string, opts map[string]OptionValueScope, result any) error {
	return v.call("nvim_get_option_value", result, name, opts)
}

// OptionValue gets the value of an option.
//
// The behavior of this function matches that of |:set|: the local value of an option is returned if it exists; otherwise,
// the global value is returned.
// Local values always correspond to the current buffer or window.
//
// To get a buffer-local or window-local option for a specific buffer or window, use BufferOption() or WindowOption().
//
// name is the option name.
//
// opts is the Optional parameters.
//
//	scope
//
// Analogous to |:setglobal| and |:setlocal|, respectively.
//
// See: [nvim_get_option_value()]
//
// [nvim_get_option_value()]: https://neovim.io/doc/user/api.html#nvim_get_option_value()
func (b *Batch) OptionValue(name string, opts map[string]OptionValueScope, result any) {
	b.call("nvim_get_option_value", &result, name, opts)
}

// SetOptionValue sets the value of an option. The behavior of this function matches that of
// |:set|: for global-local options, both the global and local value are set
// unless otherwise specified with {scope}.
// name is the option name.
//
// opts is the Optional parameters.
//
//	scope
//
// Analogous to |:setglobal| and |:setlocal|, respectively.
//
// See: [nvim_set_option_value()]
//
// [nvim_set_option_value()]: https://neovim.io/doc/user/api.html#nvim_set_option_value()
func (v *Nvim) SetOptionValue(name string, value any, opts map[string]OptionValueScope) error {
	return v.call("nvim_set_option_value", nil, name, value, opts)
}

// SetOptionValue sets the value of an option. The behavior of this function matches that of
// |:set|: for global-local options, both the global and local value are set
// unless otherwise specified with {scope}.
// name is the option name.
//
// opts is the Optional parameters.
//
//	scope
//
// Analogous to |:setglobal| and |:setlocal|, respectively.
//
// See: [nvim_set_option_value()]
//
// [nvim_set_option_value()]: https://neovim.io/doc/user/api.html#nvim_set_option_value()
func (b *Batch) SetOptionValue(name string, value any, opts map[string]OptionValueScope) {
	b.call("nvim_set_option_value", nil, name, value, opts)
}

// AllOptionsInfo gets the option information for all options.
//
// The dictionary has the full option names as keys and option metadata
// dictionaries as detailed at OptionInfo.
//
// Resulting map has keys:
//
//	name
//
// Name of the option (like "filetype").
//
//	shortname
//
// Shortened name of the option (like "ft").
//
//	type
//
// type of option ("string", "number" or "boolean").
//
//	default
//
// The default value for the option.
//
//	was_set
//
// Whether the option was set.
//
//	last_set_sid
//
// Last set script id (if any).
//
//	last_set_linenr
//
// line number where option was set.
//
//	last_set_chan
//
// Channel where option was set (0 for local).
//
//	scope
//
// One of "global", "win", or "buf".
//
//	global_local
//
// Whether win or buf option has a global value.
//
//	commalist
//
// List of comma separated values.
//
//	flaglist
//
// List of single char flags.
//
// See: [nvim_get_all_options_info()]
//
// [nvim_get_all_options_info()]: https://neovim.io/doc/user/api.html#nvim_get_all_options_info()
func (v *Nvim) AllOptionsInfo() (opinfo *OptionInfo, err error) {
	var result OptionInfo
	err = v.call("nvim_get_all_options_info", &result)
	return &result, err
}

// AllOptionsInfo gets the option information for all options.
//
// The dictionary has the full option names as keys and option metadata
// dictionaries as detailed at OptionInfo.
//
// Resulting map has keys:
//
//	name
//
// Name of the option (like "filetype").
//
//	shortname
//
// Shortened name of the option (like "ft").
//
//	type
//
// type of option ("string", "number" or "boolean").
//
//	default
//
// The default value for the option.
//
//	was_set
//
// Whether the option was set.
//
//	last_set_sid
//
// Last set script id (if any).
//
//	last_set_linenr
//
// line number where option was set.
//
//	last_set_chan
//
// Channel where option was set (0 for local).
//
//	scope
//
// One of "global", "win", or "buf".
//
//	global_local
//
// Whether win or buf option has a global value.
//
//	commalist
//
// List of comma separated values.
//
//	flaglist
//
// List of single char flags.
//
// See: [nvim_get_all_options_info()]
//
// [nvim_get_all_options_info()]: https://neovim.io/doc/user/api.html#nvim_get_all_options_info()
func (b *Batch) AllOptionsInfo(opinfo *OptionInfo) {
	b.call("nvim_get_all_options_info", opinfo)
}

// OptionInfo gets the option information for one option.
//
// Resulting map has keys:
//
//	name
//
// Name of the option (like "filetype").
//
//	shortname
//
// Shortened name of the option (like "ft").
//
//	type
//
// type of option ("string", "number" or "boolean").
//
//	default
//
// The default value for the option.
//
//	was_set
//
// Whether the option was set.
//
//	last_set_sid
//
// Last set script id (if any).
//
//	last_set_linenr
//
// line number where option was set.
//
//	last_set_chan
//
// Channel where option was set (0 for local).
//
//	scope
//
// One of "global", "win", or "buf".
//
//	global_local
//
// Whether win or buf option has a global value.
//
//	commalist
//
// List of comma separated values.
//
//	flaglist
//
// List of single char flags.
//
// See: [nvim_get_option_info2()]
//
// [nvim_get_option_info2()]: https://neovim.io/doc/user/api.html#nvim_get_option_info2()
func (v *Nvim) OptionInfo(name string, opts map[string]any) (opinfo *OptionInfo, err error) {
	var result OptionInfo
	err = v.call("nvim_get_option_info2", &result, name, opts)
	return &result, err
}

// OptionInfo gets the option information for one option.
//
// Resulting map has keys:
//
//	name
//
// Name of the option (like "filetype").
//
//	shortname
//
// Shortened name of the option (like "ft").
//
//	type
//
// type of option ("string", "number" or "boolean").
//
//	default
//
// The default value for the option.
//
//	was_set
//
// Whether the option was set.
//
//	last_set_sid
//
// Last set script id (if any).
//
//	last_set_linenr
//
// line number where option was set.
//
//	last_set_chan
//
// Channel where option was set (0 for local).
//
//	scope
//
// One of "global", "win", or "buf".
//
//	global_local
//
// Whether win or buf option has a global value.
//
//	commalist
//
// List of comma separated values.
//
//	flaglist
//
// List of single char flags.
//
// See: [nvim_get_option_info2()]
//
// [nvim_get_option_info2()]: https://neovim.io/doc/user/api.html#nvim_get_option_info2()
func (b *Batch) OptionInfo(name string, opts map[string]any, opinfo *OptionInfo) {
	b.call("nvim_get_option_info2", opinfo, name, opts)
}

// SetOption sets an option value.
//
// See: [nvim_set_option()]
//
// [nvim_set_option()]: https://neovim.io/doc/user/api.html#nvim_set_option()
func (v *Nvim) SetOption(name string, value any) error {
	return v.call("nvim_set_option", nil, name, value)
}

// SetOption sets an option value.
//
// See: [nvim_set_option()]
//
// [nvim_set_option()]: https://neovim.io/doc/user/api.html#nvim_set_option()
func (b *Batch) SetOption(name string, value any) {
	b.call("nvim_set_option", nil, name, value)
}

// Option gets an option value string.
//
// See: [nvim_get_option()]
//
// [nvim_get_option()]: https://neovim.io/doc/user/api.html#nvim_get_option()
func (v *Nvim) Option(name string, result any) error {
	return v.call("nvim_get_option", result, name)
}

// Option gets an option value string.
//
// See: [nvim_get_option()]
//
// [nvim_get_option()]: https://neovim.io/doc/user/api.html#nvim_get_option()
func (b *Batch) Option(name string, result any) {
	b.call("nvim_get_option", &result, name)
}

// BufferOption gets a buffer option value.
//
// See: [nvim_buf_get_option()]
//
// [nvim_buf_get_option()]: https://neovim.io/doc/user/api.html#nvim_buf_get_option()
func (v *Nvim) BufferOption(buffer Buffer, name string, result any) error {
	return v.call("nvim_buf_get_option", result, buffer, name)
}

// BufferOption gets a buffer option value.
//
// See: [nvim_buf_get_option()]
//
// [nvim_buf_get_option()]: https://neovim.io/doc/user/api.html#nvim_buf_get_option()
func (b *Batch) BufferOption(buffer Buffer, name string, result any) {
	b.call("nvim_buf_get_option", &result, buffer, name)
}

// SetBufferOption sets a buffer option value.
//
// Passing nil as value arg to deletes the option (only works if there's a global fallback).
//
// See: [nvim_buf_set_option()]
//
// [nvim_buf_set_option()]: https://neovim.io/doc/user/api.html#nvim_buf_set_option()
func (v *Nvim) SetBufferOption(buffer Buffer, name string, value any) error {
	return v.call("nvim_buf_set_option", nil, buffer, name, value)
}

// SetBufferOption sets a buffer option value.
//
// Passing nil as value arg to deletes the option (only works if there's a global fallback).
//
// See: [nvim_buf_set_option()]
//
// [nvim_buf_set_option()]: https://neovim.io/doc/user/api.html#nvim_buf_set_option()
func (b *Batch) SetBufferOption(buffer Buffer, name string, value any) {
	b.call("nvim_buf_set_option", nil, buffer, name, value)
}

// WindowOption gets a window option value.
//
// See: [nvim_win_get_option()]
//
// [nvim_win_get_option()]: https://neovim.io/doc/user/api.html#nvim_win_get_option()
func (v *Nvim) WindowOption(window Window, name string, result any) error {
	return v.call("nvim_win_get_option", result, window, name)
}

// WindowOption gets a window option value.
//
// See: [nvim_win_get_option()]
//
// [nvim_win_get_option()]: https://neovim.io/doc/user/api.html#nvim_win_get_option()
func (b *Batch) WindowOption(window Window, name string, result any) {
	b.call("nvim_win_get_option", &result, window, name)
}

// SetWindowOption sets a window option value. Passing "nil" as value deletes the option(only works if there's a global fallback).
//
// See: [nvim_win_set_option()]
//
// [nvim_win_set_option()]: https://neovim.io/doc/user/api.html#nvim_win_set_option()
func (v *Nvim) SetWindowOption(window Window, name string, value any) error {
	return v.call("nvim_win_set_option", nil, window, name, value)
}

// SetWindowOption sets a window option value. Passing "nil" as value deletes the option(only works if there's a global fallback).
//
// See: [nvim_win_set_option()]
//
// [nvim_win_set_option()]: https://neovim.io/doc/user/api.html#nvim_win_set_option()
func (b *Batch) SetWindowOption(window Window, name string, value any) {
	b.call("nvim_win_set_option", nil, window, name, value)
}

// AttachUI registers the client as a remote UI. After this method is called,
// the client will receive redraw notifications.
//
//	:help rpc-remote-ui
//
// The redraw notification method has variadic arguments. Register a handler
// for the method like this:
//
//	v.RegisterHandler("redraw", func(updates ...[]any) {
//	    for _, update := range updates {
//	        // handle update
//	    }
//	})
//
// See: [nvim_ui_attach()]
//
// [nvim_ui_attach()]: https://neovim.io/doc/user/api.html#nvim_ui_attach()
func (v *Nvim) AttachUI(width int, height int, options map[string]any) error {
	return v.call("nvim_ui_attach", nil, width, height, options)
}

// AttachUI registers the client as a remote UI. After this method is called,
// the client will receive redraw notifications.
//
//	:help rpc-remote-ui
//
// The redraw notification method has variadic arguments. Register a handler
// for the method like this:
//
//	v.RegisterHandler("redraw", func(updates ...[]any) {
//	    for _, update := range updates {
//	        // handle update
//	    }
//	})
//
// See: [nvim_ui_attach()]
//
// [nvim_ui_attach()]: https://neovim.io/doc/user/api.html#nvim_ui_attach()
func (b *Batch) AttachUI(width int, height int, options map[string]any) {
	b.call("nvim_ui_attach", nil, width, height, options)
}

// SetFocusUI tells the nvim server if focus was gained or lost by the GUI.
//
// See: [nvim_ui_set_focus()]
//
// [nvim_ui_set_focus()]: https://neovim.io/doc/user/api.html#nvim_ui_set_focus()
func (v *Nvim) SetFocusUI(gained bool) error {
	return v.call("nvim_ui_set_focus", nil, gained)
}

// SetFocusUI tells the nvim server if focus was gained or lost by the GUI.
//
// See: [nvim_ui_set_focus()]
//
// [nvim_ui_set_focus()]: https://neovim.io/doc/user/api.html#nvim_ui_set_focus()
func (b *Batch) SetFocusUI(gained bool) {
	b.call("nvim_ui_set_focus", nil, gained)
}

// DetachUI unregisters the client as a remote UI.
//
// See: [nvim_ui_detach()]
//
// [nvim_ui_detach()]: https://neovim.io/doc/user/api.html#nvim_ui_detach()
func (v *Nvim) DetachUI() error {
	return v.call("nvim_ui_detach", nil)
}

// DetachUI unregisters the client as a remote UI.
//
// See: [nvim_ui_detach()]
//
// [nvim_ui_detach()]: https://neovim.io/doc/user/api.html#nvim_ui_detach()
func (b *Batch) DetachUI() {
	b.call("nvim_ui_detach", nil)
}

// TryResizeUI notifies Nvim that the client window has resized. If possible,
// Nvim will send a redraw request to resize.
//
// See: [nvim_ui_try_resize()]
//
// [nvim_ui_try_resize()]: https://neovim.io/doc/user/api.html#nvim_ui_try_resize()
func (v *Nvim) TryResizeUI(width int, height int) error {
	return v.call("nvim_ui_try_resize", nil, width, height)
}

// TryResizeUI notifies Nvim that the client window has resized. If possible,
// Nvim will send a redraw request to resize.
//
// See: [nvim_ui_try_resize()]
//
// [nvim_ui_try_resize()]: https://neovim.io/doc/user/api.html#nvim_ui_try_resize()
func (b *Batch) TryResizeUI(width int, height int) {
	b.call("nvim_ui_try_resize", nil, width, height)
}

// SetUIOption sets a UI option.
//
// See: [nvim_ui_set_option()]
//
// [nvim_ui_set_option()]: https://neovim.io/doc/user/api.html#nvim_ui_set_option()
func (v *Nvim) SetUIOption(name string, value any) error {
	return v.call("nvim_ui_set_option", nil, name, value)
}

// SetUIOption sets a UI option.
//
// See: [nvim_ui_set_option()]
//
// [nvim_ui_set_option()]: https://neovim.io/doc/user/api.html#nvim_ui_set_option()
func (b *Batch) SetUIOption(name string, value any) {
	b.call("nvim_ui_set_option", nil, name, value)
}

// TryResizeUIGrid tell Nvim to resize a grid. Triggers a grid_resize event with the requested
// grid size or the maximum size if it exceeds size limits.
//
// On invalid grid handle, fails with error.
//
// See: [nvim_ui_try_resize_grid()]
//
// [nvim_ui_try_resize_grid()]: https://neovim.io/doc/user/api.html#nvim_ui_try_resize_grid()
func (v *Nvim) TryResizeUIGrid(grid int, width int, height int) error {
	return v.call("nvim_ui_try_resize_grid", nil, grid, width, height)
}

// TryResizeUIGrid tell Nvim to resize a grid. Triggers a grid_resize event with the requested
// grid size or the maximum size if it exceeds size limits.
//
// On invalid grid handle, fails with error.
//
// See: [nvim_ui_try_resize_grid()]
//
// [nvim_ui_try_resize_grid()]: https://neovim.io/doc/user/api.html#nvim_ui_try_resize_grid()
func (b *Batch) TryResizeUIGrid(grid int, width int, height int) {
	b.call("nvim_ui_try_resize_grid", nil, grid, width, height)
}

// SetPumHeight tells Nvim the number of elements displaying in the popumenu, to decide
// <PageUp> and <PageDown> movement.
//
// height is popupmenu height, must be greater than zero.
//
// See: [nvim_ui_pum_set_height()]
//
// [nvim_ui_pum_set_height()]: https://neovim.io/doc/user/api.html#nvim_ui_pum_set_height()
func (v *Nvim) SetPumHeight(height int) error {
	return v.call("nvim_ui_pum_set_height", nil, height)
}

// SetPumHeight tells Nvim the number of elements displaying in the popumenu, to decide
// <PageUp> and <PageDown> movement.
//
// height is popupmenu height, must be greater than zero.
//
// See: [nvim_ui_pum_set_height()]
//
// [nvim_ui_pum_set_height()]: https://neovim.io/doc/user/api.html#nvim_ui_pum_set_height()
func (b *Batch) SetPumHeight(height int) {
	b.call("nvim_ui_pum_set_height", nil, height)
}

// SetPumBounds tells Nvim the geometry of the popumenu, to align floating windows with an
// external popup menu.
//
// Note that this method is not to be confused with SetPumHeight,
// which sets the number of visible items in the popup menu, while this
// function sets the bounding box of the popup menu, including visual
// elements such as borders and sliders.
//
// Floats need not use the same font size, nor be anchored to exact grid corners, so one can set floating-point
// numbers to the popup menu geometry.
//
// See: [nvim_ui_pum_set_bounds()]
//
// [nvim_ui_pum_set_bounds()]: https://neovim.io/doc/user/api.html#nvim_ui_pum_set_bounds()
func (v *Nvim) SetPumBounds(width float64, height float64, row float64, col float64) error {
	return v.call("nvim_ui_pum_set_bounds", nil, width, height, row, col)
}

// SetPumBounds tells Nvim the geometry of the popumenu, to align floating windows with an
// external popup menu.
//
// Note that this method is not to be confused with SetPumHeight,
// which sets the number of visible items in the popup menu, while this
// function sets the bounding box of the popup menu, including visual
// elements such as borders and sliders.
//
// Floats need not use the same font size, nor be anchored to exact grid corners, so one can set floating-point
// numbers to the popup menu geometry.
//
// See: [nvim_ui_pum_set_bounds()]
//
// [nvim_ui_pum_set_bounds()]: https://neovim.io/doc/user/api.html#nvim_ui_pum_set_bounds()
func (b *Batch) SetPumBounds(width float64, height float64, row float64, col float64) {
	b.call("nvim_ui_pum_set_bounds", nil, width, height, row, col)
}

// Exec executes Vimscript (multiline block of Ex-commands), like anonymous source.
//
// Unlike Command, this function supports heredocs, script-scope (s:), etc.
//
// When fails with VimL error, does not update "v:errmsg".
//
// See: [nvim_exec2()]
//
// [nvim_exec2()]: https://neovim.io/doc/user/api.html#nvim_exec2()
func (v *Nvim) Exec(src string, opts map[string]any) (out map[string]any, err error) {
	err = v.call("nvim_exec2", &out, src, opts)
	return out, err
}

// Exec executes Vimscript (multiline block of Ex-commands), like anonymous source.
//
// Unlike Command, this function supports heredocs, script-scope (s:), etc.
//
// When fails with VimL error, does not update "v:errmsg".
//
// See: [nvim_exec2()]
//
// [nvim_exec2()]: https://neovim.io/doc/user/api.html#nvim_exec2()
func (b *Batch) Exec(src string, opts map[string]any, out *map[string]any) {
	b.call("nvim_exec2", out, src, opts)
}

// Command executes an ex-command.
//
// When fails with VimL error, does not update "v:errmsg".
//
// See: [nvim_command()]
//
// [nvim_command()]: https://neovim.io/doc/user/api.html#nvim_command()
func (v *Nvim) Command(cmd string) error {
	return v.call("nvim_command", nil, cmd)
}

// Command executes an ex-command.
//
// When fails with VimL error, does not update "v:errmsg".
//
// See: [nvim_command()]
//
// [nvim_command()]: https://neovim.io/doc/user/api.html#nvim_command()
func (b *Batch) Command(cmd string) {
	b.call("nvim_command", nil, cmd)
}

// ParseExpression parse a VimL expression.
//
// See: [nvim_parse_expression()]
//
// [nvim_parse_expression()]: https://neovim.io/doc/user/api.html#nvim_parse_expression()
func (v *Nvim) ParseExpression(expr string, flags string, highlight bool) (expression map[string]any, err error) {
	err = v.call("nvim_parse_expression", &expression, expr, flags, highlight)
	return expression, err
}

// ParseExpression parse a VimL expression.
//
// See: [nvim_parse_expression()]
//
// [nvim_parse_expression()]: https://neovim.io/doc/user/api.html#nvim_parse_expression()
func (b *Batch) ParseExpression(expr string, flags string, highlight bool, expression *map[string]any) {
	b.call("nvim_parse_expression", expression, expr, flags, highlight)
}

// HL gets a highlight definition by name.
//
// nsID get highlight groups for namespace ns_id [Namespaces]. Use 0 to get global highlight groups |:highlight|.
//
// opts dict:
//
//	name
//
// Get a highlight definition by name.
//
//	id
//
// Get a highlight definition by id.
//
//	link
//
// Show linked group name instead of effective definition.
//
// The returned HLAttrs highlight groups as a map from group name to a highlight definition map as in SetHighlight, or only a single highlight definition map if requested by name or id.
//
// See: [nvim_get_hl()]
//
// [nvim_get_hl()]: https://neovim.io/doc/user/api.html#nvim_get_hl()
func (v *Nvim) HL(nsID int, opts map[string]any) (highlight *HLAttrs, err error) {
	var result HLAttrs
	err = v.call("nvim_get_hl", &result, nsID, opts)
	return &result, err
}

// HL gets a highlight definition by name.
//
// nsID get highlight groups for namespace ns_id [Namespaces]. Use 0 to get global highlight groups |:highlight|.
//
// opts dict:
//
//	name
//
// Get a highlight definition by name.
//
//	id
//
// Get a highlight definition by id.
//
//	link
//
// Show linked group name instead of effective definition.
//
// The returned HLAttrs highlight groups as a map from group name to a highlight definition map as in SetHighlight, or only a single highlight definition map if requested by name or id.
//
// See: [nvim_get_hl()]
//
// [nvim_get_hl()]: https://neovim.io/doc/user/api.html#nvim_get_hl()
func (b *Batch) HL(nsID int, opts map[string]any, highlight *HLAttrs) {
	b.call("nvim_get_hl", highlight, nsID, opts)
}

// HLIDByName gets a highlight group by name.
//
// name is the Highlight group name.
//
// The returns hlID is the highlight id.
//
// This function similar to HLByID, but allocates a new ID if not present.
//
// See: [nvim_get_hl_id_by_name()]
//
// [nvim_get_hl_id_by_name()]: https://neovim.io/doc/user/api.html#nvim_get_hl_id_by_name()
func (v *Nvim) HLIDByName(name string) (hlID int, err error) {
	err = v.call("nvim_get_hl_id_by_name", &hlID, name)
	return hlID, err
}

// HLIDByName gets a highlight group by name.
//
// name is the Highlight group name.
//
// The returns hlID is the highlight id.
//
// This function similar to HLByID, but allocates a new ID if not present.
//
// See: [nvim_get_hl_id_by_name()]
//
// [nvim_get_hl_id_by_name()]: https://neovim.io/doc/user/api.html#nvim_get_hl_id_by_name()
func (b *Batch) HLIDByName(name string, hlID *int) {
	b.call("nvim_get_hl_id_by_name", hlID, name)
}

// SetHighlight sets a highlight group.
//
// nsID is number of namespace for this highlight.
//
// name is highlight group name, like "ErrorMsg".
//
// val is highlight definiton map, like HLByName.
//
// in addition the following keys are also recognized:
//
//	default
//
// don't override existing definition, like "hi default".
//
// See: [nvim_set_hl()]
//
// [nvim_set_hl()]: https://neovim.io/doc/user/api.html#nvim_set_hl()
func (v *Nvim) SetHighlight(nsID int, name string, val *HLAttrs) error {
	return v.call("nvim_set_hl", nil, nsID, name, val)
}

// SetHighlight sets a highlight group.
//
// nsID is number of namespace for this highlight.
//
// name is highlight group name, like "ErrorMsg".
//
// val is highlight definiton map, like HLByName.
//
// in addition the following keys are also recognized:
//
//	default
//
// don't override existing definition, like "hi default".
//
// See: [nvim_set_hl()]
//
// [nvim_set_hl()]: https://neovim.io/doc/user/api.html#nvim_set_hl()
func (b *Batch) SetHighlight(nsID int, name string, val *HLAttrs) {
	b.call("nvim_set_hl", nil, nsID, name, val)
}

// SetHighlightNamespace set active namespace for highlights. This can be set for a single window,
//
// See SetWindowHeightNamespace.
//
// See: [nvim_set_hl_ns()]
//
// [nvim_set_hl_ns()]: https://neovim.io/doc/user/api.html#nvim_set_hl_ns()
func (v *Nvim) SetHighlightNamespace(nsID int) error {
	return v.call("nvim_set_hl_ns", nil, nsID)
}

// SetHighlightNamespace set active namespace for highlights. This can be set for a single window,
//
// See SetWindowHeightNamespace.
//
// See: [nvim_set_hl_ns()]
//
// [nvim_set_hl_ns()]: https://neovim.io/doc/user/api.html#nvim_set_hl_ns()
func (b *Batch) SetHighlightNamespace(nsID int) {
	b.call("nvim_set_hl_ns", nil, nsID)
}

// SetFastHighlightNamespace set active namespace for highlights while redrawing.
//
// This function meant to be called while redrawing, primarily from
// nvim_set_decoration_provider on_win and on_line callbacks, which
// are allowed to change the namespace during a redraw cycle.
//
// See: [nvim_set_hl_ns_fast()]
//
// [nvim_set_hl_ns_fast()]: https://neovim.io/doc/user/api.html#nvim_set_hl_ns_fast()
func (v *Nvim) SetFastHighlightNamespace(nsID int) error {
	return v.call("nvim_set_hl_ns_fast", nil, nsID)
}

// SetFastHighlightNamespace set active namespace for highlights while redrawing.
//
// This function meant to be called while redrawing, primarily from
// nvim_set_decoration_provider on_win and on_line callbacks, which
// are allowed to change the namespace during a redraw cycle.
//
// See: [nvim_set_hl_ns_fast()]
//
// [nvim_set_hl_ns_fast()]: https://neovim.io/doc/user/api.html#nvim_set_hl_ns_fast()
func (b *Batch) SetFastHighlightNamespace(nsID int) {
	b.call("nvim_set_hl_ns_fast", nil, nsID)
}

// FeedKeys input-keys to Nvim, subject to various quirks controlled by "mode"
// flags. Unlike Input, this is a blocking call.
//
// This function does not fail, but updates "v:errmsg".
//
// If need to input sequences like <C-o> use ReplaceTermcodes to
// replace the termcodes and then pass the resulting string to nvim_feedkeys.
// You'll also want to enable escape_csi.
//
// mode is following character flags:
//
//	m
//
// Remap keys. This is default.
//
//	n
//
// Do not remap keys.
//
//	t
//
// Handle keys as if typed; otherwise they are handled as if coming from a mapping.
// This matters for undo, opening folds, etc.
//
// escapeCSI is whether the escape K_SPECIAL/CSI bytes in keys.
//
// See: [nvim_feedkeys()]
//
// [nvim_feedkeys()]: https://neovim.io/doc/user/api.html#nvim_feedkeys()
func (v *Nvim) FeedKeys(keys string, mode string, escapeCSI bool) error {
	return v.call("nvim_feedkeys", nil, keys, mode, escapeCSI)
}

// FeedKeys input-keys to Nvim, subject to various quirks controlled by "mode"
// flags. Unlike Input, this is a blocking call.
//
// This function does not fail, but updates "v:errmsg".
//
// If need to input sequences like <C-o> use ReplaceTermcodes to
// replace the termcodes and then pass the resulting string to nvim_feedkeys.
// You'll also want to enable escape_csi.
//
// mode is following character flags:
//
//	m
//
// Remap keys. This is default.
//
//	n
//
// Do not remap keys.
//
//	t
//
// Handle keys as if typed; otherwise they are handled as if coming from a mapping.
// This matters for undo, opening folds, etc.
//
// escapeCSI is whether the escape K_SPECIAL/CSI bytes in keys.
//
// See: [nvim_feedkeys()]
//
// [nvim_feedkeys()]: https://neovim.io/doc/user/api.html#nvim_feedkeys()
func (b *Batch) FeedKeys(keys string, mode string, escapeCSI bool) {
	b.call("nvim_feedkeys", nil, keys, mode, escapeCSI)
}

// Input queues raw user-input.
//
// Unlike FeedKeys, this uses a low-level input buffer and the call
// is non-blocking (input is processed asynchronously by the eventloop).
//
// This function does not fail but updates "v:errmsg".
//
// keys is to be typed.
//
// Note: "keycodes" like "<CR>" are translated, so "<" is special. To input a literal "<", send "<LT>".
//
// Note: For mouse events use InputMouse. The pseudokey form "<LeftMouse><col,row>" is deprecated.
//
// The returned written is number of bytes actually written (can be fewer than
// requested if the buffer becomes full).
//
// See: [nvim_input()]
//
// [nvim_input()]: https://neovim.io/doc/user/api.html#nvim_input()
func (v *Nvim) Input(keys string) (written int, err error) {
	err = v.call("nvim_input", &written, keys)
	return written, err
}

// Input queues raw user-input.
//
// Unlike FeedKeys, this uses a low-level input buffer and the call
// is non-blocking (input is processed asynchronously by the eventloop).
//
// This function does not fail but updates "v:errmsg".
//
// keys is to be typed.
//
// Note: "keycodes" like "<CR>" are translated, so "<" is special. To input a literal "<", send "<LT>".
//
// Note: For mouse events use InputMouse. The pseudokey form "<LeftMouse><col,row>" is deprecated.
//
// The returned written is number of bytes actually written (can be fewer than
// requested if the buffer becomes full).
//
// See: [nvim_input()]
//
// [nvim_input()]: https://neovim.io/doc/user/api.html#nvim_input()
func (b *Batch) Input(keys string, written *int) {
	b.call("nvim_input", written, keys)
}

// InputMouse Send mouse event from GUI.
//
// This API is non-blocking. It does not wait on any result, but queues the event to be
// processed soon by the event loop.
//
// button is mouse button. One of
//
//	left
//	right
//	middle
//	wheel
//
// action is for ordinary buttons. One of
//
//	press
//	drag
//	release
//
// For the wheel, One of
//
//	up
//	down
//	left
//	right
//
// modifier is string of modifiers each represented by a single char.
// The same specifiers are used as for a key press, except
// that the "-" separator is optional, so "C-A-", "c-a"
// and "CA" can all be used to specify "Ctrl+Alt+Click".
//
// grid is grid number if the client uses "ui-multigrid", else 0.
//
// row is mouse row-position (zero-based, like redraw events).
//
// col is mouse column-position (zero-based, like redraw events).
//
// See: [nvim_input_mouse()]
//
// [nvim_input_mouse()]: https://neovim.io/doc/user/api.html#nvim_input_mouse()
func (v *Nvim) InputMouse(button string, action string, modifier string, grid int, row int, col int) error {
	return v.call("nvim_input_mouse", nil, button, action, modifier, grid, row, col)
}

// InputMouse Send mouse event from GUI.
//
// This API is non-blocking. It does not wait on any result, but queues the event to be
// processed soon by the event loop.
//
// button is mouse button. One of
//
//	left
//	right
//	middle
//	wheel
//
// action is for ordinary buttons. One of
//
//	press
//	drag
//	release
//
// For the wheel, One of
//
//	up
//	down
//	left
//	right
//
// modifier is string of modifiers each represented by a single char.
// The same specifiers are used as for a key press, except
// that the "-" separator is optional, so "C-A-", "c-a"
// and "CA" can all be used to specify "Ctrl+Alt+Click".
//
// grid is grid number if the client uses "ui-multigrid", else 0.
//
// row is mouse row-position (zero-based, like redraw events).
//
// col is mouse column-position (zero-based, like redraw events).
//
// See: [nvim_input_mouse()]
//
// [nvim_input_mouse()]: https://neovim.io/doc/user/api.html#nvim_input_mouse()
func (b *Batch) InputMouse(button string, action string, modifier string, grid int, row int, col int) {
	b.call("nvim_input_mouse", nil, button, action, modifier, grid, row, col)
}

// ReplaceTermcodes replaces terminal codes and "keycodes" (<CR>, <Esc>, ...) in a string with
// the internal representation.
//
// str is string to be converted.
//
// fromPart is legacy Vim parameter. Usually true.
//
// doLT is also translate <lt>. Ignored if "special" is false.
//
// special is replace "keycodes", e.g. "<CR>" becomes a "\n" char.
//
// The returned sequences are Nvim's internal representation of keys, for example:
//
//	<esc> -> '\x1b'
//	<cr>  -> '\r'
//	<c-l> -> '\x0c'
//	<up>  -> '\x80ku'
//
// The returned sequences can be used as input to feedkeys.
//
// See: [nvim_replace_termcodes()]
//
// [nvim_replace_termcodes()]: https://neovim.io/doc/user/api.html#nvim_replace_termcodes()
func (v *Nvim) ReplaceTermcodes(str string, fromPart bool, doLT bool, special bool) (input string, err error) {
	err = v.call("nvim_replace_termcodes", &input, str, fromPart, doLT, special)
	return input, err
}

// ReplaceTermcodes replaces terminal codes and "keycodes" (<CR>, <Esc>, ...) in a string with
// the internal representation.
//
// str is string to be converted.
//
// fromPart is legacy Vim parameter. Usually true.
//
// doLT is also translate <lt>. Ignored if "special" is false.
//
// special is replace "keycodes", e.g. "<CR>" becomes a "\n" char.
//
// The returned sequences are Nvim's internal representation of keys, for example:
//
//	<esc> -> '\x1b'
//	<cr>  -> '\r'
//	<c-l> -> '\x0c'
//	<up>  -> '\x80ku'
//
// The returned sequences can be used as input to feedkeys.
//
// See: [nvim_replace_termcodes()]
//
// [nvim_replace_termcodes()]: https://neovim.io/doc/user/api.html#nvim_replace_termcodes()
func (b *Batch) ReplaceTermcodes(str string, fromPart bool, doLT bool, special bool, input *string) {
	b.call("nvim_replace_termcodes", input, str, fromPart, doLT, special)
}

// Eval evaluates a VimL expression.
//
// Dictionaries and Lists are recursively expanded.
//
// Fails with VimL error, does not update "v:errmsg".
//
// expr is VimL expression string.
//
//	:help expression
//
// See: [nvim_eval()]
//
// [nvim_eval()]: https://neovim.io/doc/user/api.html#nvim_eval()
func (v *Nvim) Eval(expr string, result any) error {
	return v.call("nvim_eval", result, expr)
}

// Eval evaluates a VimL expression.
//
// Dictionaries and Lists are recursively expanded.
//
// Fails with VimL error, does not update "v:errmsg".
//
// expr is VimL expression string.
//
//	:help expression
//
// See: [nvim_eval()]
//
// [nvim_eval()]: https://neovim.io/doc/user/api.html#nvim_eval()
func (b *Batch) Eval(expr string, result any) {
	b.call("nvim_eval", &result, expr)
}

// StringWidth calculates the number of display cells occupied by "text".
//
// "<Tab>" counts as one cell.
//
// See: [nvim_strwidth()]
//
// [nvim_strwidth()]: https://neovim.io/doc/user/api.html#nvim_strwidth()
func (v *Nvim) StringWidth(s string) (width int, err error) {
	err = v.call("nvim_strwidth", &width, s)
	return width, err
}

// StringWidth calculates the number of display cells occupied by "text".
//
// "<Tab>" counts as one cell.
//
// See: [nvim_strwidth()]
//
// [nvim_strwidth()]: https://neovim.io/doc/user/api.html#nvim_strwidth()
func (b *Batch) StringWidth(s string, width *int) {
	b.call("nvim_strwidth", width, s)
}

// RuntimePaths gets the paths contained in "runtimepath".
//
// See: [nvim_list_runtime_paths()]
//
// [nvim_list_runtime_paths()]: https://neovim.io/doc/user/api.html#nvim_list_runtime_paths()
func (v *Nvim) RuntimePaths() (paths []string, err error) {
	err = v.call("nvim_list_runtime_paths", &paths)
	return paths, err
}

// RuntimePaths gets the paths contained in "runtimepath".
//
// See: [nvim_list_runtime_paths()]
//
// [nvim_list_runtime_paths()]: https://neovim.io/doc/user/api.html#nvim_list_runtime_paths()
func (b *Batch) RuntimePaths(paths *[]string) {
	b.call("nvim_list_runtime_paths", paths)
}

// RuntimeFiles find files in runtime directories.
//
// name is can contain wildcards.
//
// For example,
//
//	RuntimeFiles("colors/*.vim", true)
//
// will return all color scheme files.
//
// Always use forward slashes (/) in the search pattern for subdirectories regardless of platform.
//
// It is not an error to not find any files, returned an empty array.
//
// To find a directory, name must end with a forward slash, like
// "rplugin/python/".
// Without the slash it would instead look for an ordinary file called "rplugin/python".
//
// all is whether to return all matches or only the first.
//
// See: [nvim_get_runtime_file()]
//
// [nvim_get_runtime_file()]: https://neovim.io/doc/user/api.html#nvim_get_runtime_file()
func (v *Nvim) RuntimeFiles(name string, all bool) (files []string, err error) {
	err = v.call("nvim_get_runtime_file", &files, name, all)
	return files, err
}

// RuntimeFiles find files in runtime directories.
//
// name is can contain wildcards.
//
// For example,
//
//	RuntimeFiles("colors/*.vim", true)
//
// will return all color scheme files.
//
// Always use forward slashes (/) in the search pattern for subdirectories regardless of platform.
//
// It is not an error to not find any files, returned an empty array.
//
// To find a directory, name must end with a forward slash, like
// "rplugin/python/".
// Without the slash it would instead look for an ordinary file called "rplugin/python".
//
// all is whether to return all matches or only the first.
//
// See: [nvim_get_runtime_file()]
//
// [nvim_get_runtime_file()]: https://neovim.io/doc/user/api.html#nvim_get_runtime_file()
func (b *Batch) RuntimeFiles(name string, all bool, files *[]string) {
	b.call("nvim_get_runtime_file", files, name, all)
}

// SetCurrentDirectory changes the global working directory.
//
// See: [nvim_set_current_dir()]
//
// [nvim_set_current_dir()]: https://neovim.io/doc/user/api.html#nvim_set_current_dir()
func (v *Nvim) SetCurrentDirectory(dir string) error {
	return v.call("nvim_set_current_dir", nil, dir)
}

// SetCurrentDirectory changes the global working directory.
//
// See: [nvim_set_current_dir()]
//
// [nvim_set_current_dir()]: https://neovim.io/doc/user/api.html#nvim_set_current_dir()
func (b *Batch) SetCurrentDirectory(dir string) {
	b.call("nvim_set_current_dir", nil, dir)
}

// CurrentLine gets the current line.
//
// See: [nvim_get_current_line()]
//
// [nvim_get_current_line()]: https://neovim.io/doc/user/api.html#nvim_get_current_line()
func (v *Nvim) CurrentLine() (line []byte, err error) {
	err = v.call("nvim_get_current_line", &line)
	return line, err
}

// CurrentLine gets the current line.
//
// See: [nvim_get_current_line()]
//
// [nvim_get_current_line()]: https://neovim.io/doc/user/api.html#nvim_get_current_line()
func (b *Batch) CurrentLine(line *[]byte) {
	b.call("nvim_get_current_line", line)
}

// SetCurrentLine sets the current line.
//
// See: [nvim_set_current_line()]
//
// [nvim_set_current_line()]: https://neovim.io/doc/user/api.html#nvim_set_current_line()
func (v *Nvim) SetCurrentLine(line []byte) error {
	return v.call("nvim_set_current_line", nil, line)
}

// SetCurrentLine sets the current line.
//
// See: [nvim_set_current_line()]
//
// [nvim_set_current_line()]: https://neovim.io/doc/user/api.html#nvim_set_current_line()
func (b *Batch) SetCurrentLine(line []byte) {
	b.call("nvim_set_current_line", nil, line)
}

// DeleteCurrentLine deletes the current line.
//
// See: [nvim_del_current_line()]
//
// [nvim_del_current_line()]: https://neovim.io/doc/user/api.html#nvim_del_current_line()
func (v *Nvim) DeleteCurrentLine() error {
	return v.call("nvim_del_current_line", nil)
}

// DeleteCurrentLine deletes the current line.
//
// See: [nvim_del_current_line()]
//
// [nvim_del_current_line()]: https://neovim.io/doc/user/api.html#nvim_del_current_line()
func (b *Batch) DeleteCurrentLine() {
	b.call("nvim_del_current_line", nil)
}

// Var gets a global (g:) variable.
//
// See: [nvim_get_var()]
//
// [nvim_get_var()]: https://neovim.io/doc/user/api.html#nvim_get_var()
func (v *Nvim) Var(name string, result any) error {
	return v.call("nvim_get_var", result, name)
}

// Var gets a global (g:) variable.
//
// See: [nvim_get_var()]
//
// [nvim_get_var()]: https://neovim.io/doc/user/api.html#nvim_get_var()
func (b *Batch) Var(name string, result any) {
	b.call("nvim_get_var", &result, name)
}

// SetVar sets a global (g:) variable.
//
// See: [nvim_set_var()]
//
// [nvim_set_var()]: https://neovim.io/doc/user/api.html#nvim_set_var()
func (v *Nvim) SetVar(name string, value any) error {
	return v.call("nvim_set_var", nil, name, value)
}

// SetVar sets a global (g:) variable.
//
// See: [nvim_set_var()]
//
// [nvim_set_var()]: https://neovim.io/doc/user/api.html#nvim_set_var()
func (b *Batch) SetVar(name string, value any) {
	b.call("nvim_set_var", nil, name, value)
}

// DeleteVar removes a global (g:) variable.
//
// See: [nvim_del_var()]
//
// [nvim_del_var()]: https://neovim.io/doc/user/api.html#nvim_del_var()
func (v *Nvim) DeleteVar(name string) error {
	return v.call("nvim_del_var", nil, name)
}

// DeleteVar removes a global (g:) variable.
//
// See: [nvim_del_var()]
//
// [nvim_del_var()]: https://neovim.io/doc/user/api.html#nvim_del_var()
func (b *Batch) DeleteVar(name string) {
	b.call("nvim_del_var", nil, name)
}

// VVar gets a v: variable.
//
// See: [nvim_get_vvar()]
//
// [nvim_get_vvar()]: https://neovim.io/doc/user/api.html#nvim_get_vvar()
func (v *Nvim) VVar(name string, result any) error {
	return v.call("nvim_get_vvar", result, name)
}

// VVar gets a v: variable.
//
// See: [nvim_get_vvar()]
//
// [nvim_get_vvar()]: https://neovim.io/doc/user/api.html#nvim_get_vvar()
func (b *Batch) VVar(name string, result any) {
	b.call("nvim_get_vvar", &result, name)
}

// SetVVar sets a v: variable, if it is not readonly.
//
// See: [nvim_set_vvar()]
//
// [nvim_set_vvar()]: https://neovim.io/doc/user/api.html#nvim_set_vvar()
func (v *Nvim) SetVVar(name string, value any) error {
	return v.call("nvim_set_vvar", nil, name, value)
}

// SetVVar sets a v: variable, if it is not readonly.
//
// See: [nvim_set_vvar()]
//
// [nvim_set_vvar()]: https://neovim.io/doc/user/api.html#nvim_set_vvar()
func (b *Batch) SetVVar(name string, value any) {
	b.call("nvim_set_vvar", nil, name, value)
}

// Echo echo a message.
//
// chunks is a list of [text, hl_group] arrays, each representing a
// text chunk with specified highlight. hl_group element can be omitted for no highlight.
//
// If history is true, add to "message-history".
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_echo()]
//
// [nvim_echo()]: https://neovim.io/doc/user/api.html#nvim_echo()
func (v *Nvim) Echo(chunks []TextChunk, history bool, opts map[string]any) error {
	return v.call("nvim_echo", nil, chunks, history, opts)
}

// Echo echo a message.
//
// chunks is a list of [text, hl_group] arrays, each representing a
// text chunk with specified highlight. hl_group element can be omitted for no highlight.
//
// If history is true, add to "message-history".
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_echo()]
//
// [nvim_echo()]: https://neovim.io/doc/user/api.html#nvim_echo()
func (b *Batch) Echo(chunks []TextChunk, history bool, opts map[string]any) {
	b.call("nvim_echo", nil, chunks, history, opts)
}

// WriteOut writes a message to the Vim output buffer.
//
// Does not append "\n", the message is buffered (won't display) until a linefeed is written.
//
// See: [nvim_out_write()]
//
// [nvim_out_write()]: https://neovim.io/doc/user/api.html#nvim_out_write()
func (v *Nvim) WriteOut(str string) error {
	return v.call("nvim_out_write", nil, str)
}

// WriteOut writes a message to the Vim output buffer.
//
// Does not append "\n", the message is buffered (won't display) until a linefeed is written.
//
// See: [nvim_out_write()]
//
// [nvim_out_write()]: https://neovim.io/doc/user/api.html#nvim_out_write()
func (b *Batch) WriteOut(str string) {
	b.call("nvim_out_write", nil, str)
}

// WriteErr writes a message to the Vim error buffer.
//
// Does not append "\n", the message is buffered (won't display) until a linefeed is written.
//
// See: [nvim_err_write()]
//
// [nvim_err_write()]: https://neovim.io/doc/user/api.html#nvim_err_write()
func (v *Nvim) WriteErr(str string) error {
	return v.call("nvim_err_write", nil, str)
}

// WriteErr writes a message to the Vim error buffer.
//
// Does not append "\n", the message is buffered (won't display) until a linefeed is written.
//
// See: [nvim_err_write()]
//
// [nvim_err_write()]: https://neovim.io/doc/user/api.html#nvim_err_write()
func (b *Batch) WriteErr(str string) {
	b.call("nvim_err_write", nil, str)
}

// WritelnErr writes a message to the Vim error buffer.
//
// Appends "\n", so the buffer is flushed and displayed.
//
// See: [nvim_err_writeln()]
//
// [nvim_err_writeln()]: https://neovim.io/doc/user/api.html#nvim_err_writeln()
func (v *Nvim) WritelnErr(str string) error {
	return v.call("nvim_err_writeln", nil, str)
}

// WritelnErr writes a message to the Vim error buffer.
//
// Appends "\n", so the buffer is flushed and displayed.
//
// See: [nvim_err_writeln()]
//
// [nvim_err_writeln()]: https://neovim.io/doc/user/api.html#nvim_err_writeln()
func (b *Batch) WritelnErr(str string) {
	b.call("nvim_err_writeln", nil, str)
}

// Buffers gets the current list of buffer handles.
//
// Includes unlisted (unloaded/deleted) buffers, like ":ls!". Use IsBufferLoaded to check if a buffer is loaded.
//
// See: [nvim_list_bufs()]
//
// [nvim_list_bufs()]: https://neovim.io/doc/user/api.html#nvim_list_bufs()
func (v *Nvim) Buffers() (buffers []Buffer, err error) {
	err = v.call("nvim_list_bufs", &buffers)
	return buffers, err
}

// Buffers gets the current list of buffer handles.
//
// Includes unlisted (unloaded/deleted) buffers, like ":ls!". Use IsBufferLoaded to check if a buffer is loaded.
//
// See: [nvim_list_bufs()]
//
// [nvim_list_bufs()]: https://neovim.io/doc/user/api.html#nvim_list_bufs()
func (b *Batch) Buffers(buffers *[]Buffer) {
	b.call("nvim_list_bufs", buffers)
}

// CurrentBuffer gets the current buffer.
//
// See: [nvim_get_current_buf()]
//
// [nvim_get_current_buf()]: https://neovim.io/doc/user/api.html#nvim_get_current_buf()
func (v *Nvim) CurrentBuffer() (buffer Buffer, err error) {
	err = v.call("nvim_get_current_buf", &buffer)
	return buffer, err
}

// CurrentBuffer gets the current buffer.
//
// See: [nvim_get_current_buf()]
//
// [nvim_get_current_buf()]: https://neovim.io/doc/user/api.html#nvim_get_current_buf()
func (b *Batch) CurrentBuffer(buffer *Buffer) {
	b.call("nvim_get_current_buf", buffer)
}

// SetCurrentBuffer sets the current buffer.
//
// See: [nvim_set_current_buf()]
//
// [nvim_set_current_buf()]: https://neovim.io/doc/user/api.html#nvim_set_current_buf()
func (v *Nvim) SetCurrentBuffer(buffer Buffer) error {
	return v.call("nvim_set_current_buf", nil, buffer)
}

// SetCurrentBuffer sets the current buffer.
//
// See: [nvim_set_current_buf()]
//
// [nvim_set_current_buf()]: https://neovim.io/doc/user/api.html#nvim_set_current_buf()
func (b *Batch) SetCurrentBuffer(buffer Buffer) {
	b.call("nvim_set_current_buf", nil, buffer)
}

// Windows gets the current list of window handles.
//
// See: [nvim_list_wins()]
//
// [nvim_list_wins()]: https://neovim.io/doc/user/api.html#nvim_list_wins()
func (v *Nvim) Windows() (windows []Window, err error) {
	err = v.call("nvim_list_wins", &windows)
	return windows, err
}

// Windows gets the current list of window handles.
//
// See: [nvim_list_wins()]
//
// [nvim_list_wins()]: https://neovim.io/doc/user/api.html#nvim_list_wins()
func (b *Batch) Windows(windows *[]Window) {
	b.call("nvim_list_wins", windows)
}

// CurrentWindow gets the current window.
//
// See: [nvim_get_current_win()]
//
// [nvim_get_current_win()]: https://neovim.io/doc/user/api.html#nvim_get_current_win()
func (v *Nvim) CurrentWindow() (window Window, err error) {
	err = v.call("nvim_get_current_win", &window)
	return window, err
}

// CurrentWindow gets the current window.
//
// See: [nvim_get_current_win()]
//
// [nvim_get_current_win()]: https://neovim.io/doc/user/api.html#nvim_get_current_win()
func (b *Batch) CurrentWindow(window *Window) {
	b.call("nvim_get_current_win", window)
}

// SetCurrentWindow sets the current window.
//
// See: [nvim_set_current_win()]
//
// [nvim_set_current_win()]: https://neovim.io/doc/user/api.html#nvim_set_current_win()
func (v *Nvim) SetCurrentWindow(window Window) error {
	return v.call("nvim_set_current_win", nil, window)
}

// SetCurrentWindow sets the current window.
//
// See: [nvim_set_current_win()]
//
// [nvim_set_current_win()]: https://neovim.io/doc/user/api.html#nvim_set_current_win()
func (b *Batch) SetCurrentWindow(window Window) {
	b.call("nvim_set_current_win", nil, window)
}

// CreateBuffer creates a new, empty, unnamed buffer.
//
// listed is sets buflisted buffer opttion. If false, sets "nobuflisted".
//
// scratch is creates a "throwaway" for temporary work (always 'nomodified').
//
//	bufhidden=hide
//	buftype=nofile
//	noswapfile
//	nomodeline
//
// See: [nvim_create_buf()]
//
// [nvim_create_buf()]: https://neovim.io/doc/user/api.html#nvim_create_buf()
func (v *Nvim) CreateBuffer(listed bool, scratch bool) (buffer Buffer, err error) {
	err = v.call("nvim_create_buf", &buffer, listed, scratch)
	return buffer, err
}

// CreateBuffer creates a new, empty, unnamed buffer.
//
// listed is sets buflisted buffer opttion. If false, sets "nobuflisted".
//
// scratch is creates a "throwaway" for temporary work (always 'nomodified').
//
//	bufhidden=hide
//	buftype=nofile
//	noswapfile
//	nomodeline
//
// See: [nvim_create_buf()]
//
// [nvim_create_buf()]: https://neovim.io/doc/user/api.html#nvim_create_buf()
func (b *Batch) CreateBuffer(listed bool, scratch bool, buffer *Buffer) {
	b.call("nvim_create_buf", buffer, listed, scratch)
}

// OpenTerm opens a terminal instance in a buffer.
//
// By default (and currently the only option) the terminal will not be
// connected to an external process. Instead, input send on the channel
// will be echoed directly by the terminal. This is useful to disply
// ANSI terminal sequences returned as part of a rpc message, or similar.
//
// Note that to directly initiate the terminal using the right size, display the
// buffer in a configured window before calling this. For instance, for a
// floating display, first create an empty buffer using CreateBuffer,
// then display it using OpenWindow, and then call this function.
// Then "nvim_chan_send" cal be called immediately to process sequences
// in a virtual terminal having the intended size.
//
// buffer is the buffer to use (expected to be empty).
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_open_term()]
//
// [nvim_open_term()]: https://neovim.io/doc/user/api.html#nvim_open_term()
func (v *Nvim) OpenTerm(buffer Buffer, opts map[string]any) (channel int, err error) {
	err = v.call("nvim_open_term", &channel, buffer, opts)
	return channel, err
}

// OpenTerm opens a terminal instance in a buffer.
//
// By default (and currently the only option) the terminal will not be
// connected to an external process. Instead, input send on the channel
// will be echoed directly by the terminal. This is useful to disply
// ANSI terminal sequences returned as part of a rpc message, or similar.
//
// Note that to directly initiate the terminal using the right size, display the
// buffer in a configured window before calling this. For instance, for a
// floating display, first create an empty buffer using CreateBuffer,
// then display it using OpenWindow, and then call this function.
// Then "nvim_chan_send" cal be called immediately to process sequences
// in a virtual terminal having the intended size.
//
// buffer is the buffer to use (expected to be empty).
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_open_term()]
//
// [nvim_open_term()]: https://neovim.io/doc/user/api.html#nvim_open_term()
func (b *Batch) OpenTerm(buffer Buffer, opts map[string]any, channel *int) {
	b.call("nvim_open_term", channel, buffer, opts)
}

// OpenWindow open a new window.
//
// Currently this is used to open floating and external windows.
// Floats are windows that are drawn above the split layout, at some anchor
// position in some other window.
// Floats can be drawn internally or by external GUI with the "ui-multigrid" extension.
// External windows are only supported with multigrid GUIs, and are displayed as separate top-level windows.
//
// For a general overview of floats, see
//
//	:help api-floatwin
//
// Exactly one of "external" and "relative" must be specified.
// The "width" and "height" of the new window must be specified.
//
// With relative=editor (row=0,col=0) refers to the top-left corner of the
// screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right
// corner.
// Fractional values are allowed, but the builtin implementation
// (used by non-multigrid UIs) will always round down to nearest integer.
//
// Out-of-bounds values, and configurations that make the float not fit inside
// the main editor, are allowed.
// The builtin implementation truncates values so floats are fully within the main screen grid.
// External GUIs could let floats hover outside of the main window like a tooltip, but
// this should not be used to specify arbitrary WM screen positions.
//
// See: [nvim_open_win()]
//
// [nvim_open_win()]: https://neovim.io/doc/user/api.html#nvim_open_win()
func (v *Nvim) OpenWindow(buffer Buffer, enter bool, config *WindowConfig) (window Window, err error) {
	err = v.call("nvim_open_win", &window, buffer, enter, config)
	return window, err
}

// OpenWindow open a new window.
//
// Currently this is used to open floating and external windows.
// Floats are windows that are drawn above the split layout, at some anchor
// position in some other window.
// Floats can be drawn internally or by external GUI with the "ui-multigrid" extension.
// External windows are only supported with multigrid GUIs, and are displayed as separate top-level windows.
//
// For a general overview of floats, see
//
//	:help api-floatwin
//
// Exactly one of "external" and "relative" must be specified.
// The "width" and "height" of the new window must be specified.
//
// With relative=editor (row=0,col=0) refers to the top-left corner of the
// screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right
// corner.
// Fractional values are allowed, but the builtin implementation
// (used by non-multigrid UIs) will always round down to nearest integer.
//
// Out-of-bounds values, and configurations that make the float not fit inside
// the main editor, are allowed.
// The builtin implementation truncates values so floats are fully within the main screen grid.
// External GUIs could let floats hover outside of the main window like a tooltip, but
// this should not be used to specify arbitrary WM screen positions.
//
// See: [nvim_open_win()]
//
// [nvim_open_win()]: https://neovim.io/doc/user/api.html#nvim_open_win()
func (b *Batch) OpenWindow(buffer Buffer, enter bool, config *WindowConfig, window *Window) {
	b.call("nvim_open_win", window, buffer, enter, config)
}

// Tabpages gets the current list of tabpage handles.
//
// See: [nvim_list_tabpages()]
//
// [nvim_list_tabpages()]: https://neovim.io/doc/user/api.html#nvim_list_tabpages()
func (v *Nvim) Tabpages() (tabpages []Tabpage, err error) {
	err = v.call("nvim_list_tabpages", &tabpages)
	return tabpages, err
}

// Tabpages gets the current list of tabpage handles.
//
// See: [nvim_list_tabpages()]
//
// [nvim_list_tabpages()]: https://neovim.io/doc/user/api.html#nvim_list_tabpages()
func (b *Batch) Tabpages(tabpages *[]Tabpage) {
	b.call("nvim_list_tabpages", tabpages)
}

// CurrentTabpage gets the current tabpage.
//
// See: [nvim_get_current_tabpage()]
//
// [nvim_get_current_tabpage()]: https://neovim.io/doc/user/api.html#nvim_get_current_tabpage()
func (v *Nvim) CurrentTabpage() (tabpage Tabpage, err error) {
	err = v.call("nvim_get_current_tabpage", &tabpage)
	return tabpage, err
}

// CurrentTabpage gets the current tabpage.
//
// See: [nvim_get_current_tabpage()]
//
// [nvim_get_current_tabpage()]: https://neovim.io/doc/user/api.html#nvim_get_current_tabpage()
func (b *Batch) CurrentTabpage(tabpage *Tabpage) {
	b.call("nvim_get_current_tabpage", tabpage)
}

// SetCurrentTabpage sets the current tabpage.
//
// See: [nvim_set_current_tabpage()]
//
// [nvim_set_current_tabpage()]: https://neovim.io/doc/user/api.html#nvim_set_current_tabpage()
func (v *Nvim) SetCurrentTabpage(tabpage Tabpage) error {
	return v.call("nvim_set_current_tabpage", nil, tabpage)
}

// SetCurrentTabpage sets the current tabpage.
//
// See: [nvim_set_current_tabpage()]
//
// [nvim_set_current_tabpage()]: https://neovim.io/doc/user/api.html#nvim_set_current_tabpage()
func (b *Batch) SetCurrentTabpage(tabpage Tabpage) {
	b.call("nvim_set_current_tabpage", nil, tabpage)
}

// Namespaces gets existing, non-anonymous namespaces.
//
// The return dict that maps from names to namespace ids.
//
// See: [nvim_get_namespaces()]
//
// [nvim_get_namespaces()]: https://neovim.io/doc/user/api.html#nvim_get_namespaces()
func (v *Nvim) Namespaces() (namespaces map[string]int, err error) {
	err = v.call("nvim_get_namespaces", &namespaces)
	return namespaces, err
}

// Namespaces gets existing, non-anonymous namespaces.
//
// The return dict that maps from names to namespace ids.
//
// See: [nvim_get_namespaces()]
//
// [nvim_get_namespaces()]: https://neovim.io/doc/user/api.html#nvim_get_namespaces()
func (b *Batch) Namespaces(namespaces *map[string]int) {
	b.call("nvim_get_namespaces", namespaces)
}

// Paste pastes at cursor, in any mode.
//
// Invokes the "vim.paste" handler, which handles each mode appropriately.
// Sets redo/undo. Faster than Input(). Lines break at LF ("\n").
//
// Errors ("nomodifiable", "vim.paste()" "failure" ...) are reflected in `err`
// but do not affect the return value (which is strictly decided by `vim.paste()`).
//
// On error, subsequent calls are ignored ("drained") until the next paste is initiated (phase 1 or -1).
//
//	data
//
// multiline input. May be binary (containing NUL bytes).
//
//	crlf
//
// also break lines at CR and CRLF.
//
//	phase
//
// -1 is paste in a single call (i.e. without streaming).
//
// To stream a paste, call Paste sequentially with these phase args:
//
//	1
//
// starts the paste (exactly once)
//
//	2
//
// continues the paste (zero or more times)
//
//	3
//
// ends the paste (exactly once)
//
// The returned boolean state is:
//
//	true
//
// Client may continue pasting.
//
//	false
//
// Client must cancel the paste.
//
// See: [nvim_paste()]
//
// [nvim_paste()]: https://neovim.io/doc/user/api.html#nvim_paste()
func (v *Nvim) Paste(data string, crlf bool, phase int) (state bool, err error) {
	err = v.call("nvim_paste", &state, data, crlf, phase)
	return state, err
}

// Paste pastes at cursor, in any mode.
//
// Invokes the "vim.paste" handler, which handles each mode appropriately.
// Sets redo/undo. Faster than Input(). Lines break at LF ("\n").
//
// Errors ("nomodifiable", "vim.paste()" "failure" ...) are reflected in `err`
// but do not affect the return value (which is strictly decided by `vim.paste()`).
//
// On error, subsequent calls are ignored ("drained") until the next paste is initiated (phase 1 or -1).
//
//	data
//
// multiline input. May be binary (containing NUL bytes).
//
//	crlf
//
// also break lines at CR and CRLF.
//
//	phase
//
// -1 is paste in a single call (i.e. without streaming).
//
// To stream a paste, call Paste sequentially with these phase args:
//
//	1
//
// starts the paste (exactly once)
//
//	2
//
// continues the paste (zero or more times)
//
//	3
//
// ends the paste (exactly once)
//
// The returned boolean state is:
//
//	true
//
// Client may continue pasting.
//
//	false
//
// Client must cancel the paste.
//
// See: [nvim_paste()]
//
// [nvim_paste()]: https://neovim.io/doc/user/api.html#nvim_paste()
func (b *Batch) Paste(data string, crlf bool, phase int, state *bool) {
	b.call("nvim_paste", state, data, crlf, phase)
}

// Put puts text at cursor, in any mode.
//
// Compare :put and p which are always linewise.
//
// lines is readfile() style list of lines.
//
// typ is edit behavior: any getregtype() result, or:
//
//	 b
//	blockwise-visual mode (may include width, e.g. "b3")
//	 c
//	characterwise mode
//	 l
//	linewise mode
//	 ""
//
// guess by contents, see |setreg()|.
//
// After is insert after cursor (like `p`), or before (like `P`).
//
// follow arg is place cursor at end of inserted text.
//
// See: [nvim_put()]
//
// [nvim_put()]: https://neovim.io/doc/user/api.html#nvim_put()
func (v *Nvim) Put(lines []string, typ string, after bool, follow bool) error {
	return v.call("nvim_put", nil, lines, typ, after, follow)
}

// Put puts text at cursor, in any mode.
//
// Compare :put and p which are always linewise.
//
// lines is readfile() style list of lines.
//
// typ is edit behavior: any getregtype() result, or:
//
//	 b
//	blockwise-visual mode (may include width, e.g. "b3")
//	 c
//	characterwise mode
//	 l
//	linewise mode
//	 ""
//
// guess by contents, see |setreg()|.
//
// After is insert after cursor (like `p`), or before (like `P`).
//
// follow arg is place cursor at end of inserted text.
//
// See: [nvim_put()]
//
// [nvim_put()]: https://neovim.io/doc/user/api.html#nvim_put()
func (b *Batch) Put(lines []string, typ string, after bool, follow bool) {
	b.call("nvim_put", nil, lines, typ, after, follow)
}

// Subscribe subscribes to event broadcasts.
//
// See: [nvim_subscribe()]
//
// [nvim_subscribe()]: https://neovim.io/doc/user/api.html#nvim_subscribe()
func (v *Nvim) Subscribe(event string) error {
	return v.call("nvim_subscribe", nil, event)
}

// Subscribe subscribes to event broadcasts.
//
// See: [nvim_subscribe()]
//
// [nvim_subscribe()]: https://neovim.io/doc/user/api.html#nvim_subscribe()
func (b *Batch) Subscribe(event string) {
	b.call("nvim_subscribe", nil, event)
}

// Unsubscribe unsubscribes to event broadcasts.
//
// See: [nvim_unsubscribe()]
//
// [nvim_unsubscribe()]: https://neovim.io/doc/user/api.html#nvim_unsubscribe()
func (v *Nvim) Unsubscribe(event string) error {
	return v.call("nvim_unsubscribe", nil, event)
}

// Unsubscribe unsubscribes to event broadcasts.
//
// See: [nvim_unsubscribe()]
//
// [nvim_unsubscribe()]: https://neovim.io/doc/user/api.html#nvim_unsubscribe()
func (b *Batch) Unsubscribe(event string) {
	b.call("nvim_unsubscribe", nil, event)
}

// ColorByName Returns the 24-bit RGB value of a ColorMap color name or "#rrggbb" hexadecimal string.
//
// Example:
//
//	ColorByName("Pink")
//	ColorByName("#cbcbcb")
//
// See: [nvim_get_color_by_name()]
//
// [nvim_get_color_by_name()]: https://neovim.io/doc/user/api.html#nvim_get_color_by_name()
func (v *Nvim) ColorByName(name string) (color int, err error) {
	err = v.call("nvim_get_color_by_name", &color, name)
	return color, err
}

// ColorByName Returns the 24-bit RGB value of a ColorMap color name or "#rrggbb" hexadecimal string.
//
// Example:
//
//	ColorByName("Pink")
//	ColorByName("#cbcbcb")
//
// See: [nvim_get_color_by_name()]
//
// [nvim_get_color_by_name()]: https://neovim.io/doc/user/api.html#nvim_get_color_by_name()
func (b *Batch) ColorByName(name string, color *int) {
	b.call("nvim_get_color_by_name", color, name)
}

// ColorMap returns a map of color names and RGB values.
//
// Keys are color names (e.g. "Aqua") and values are 24-bit RGB color values (e.g. 65535).
//
// The returns map is color names and RGB values.
//
// See: [nvim_get_color_map()]
//
// [nvim_get_color_map()]: https://neovim.io/doc/user/api.html#nvim_get_color_map()
func (v *Nvim) ColorMap() (colorMap map[string]int, err error) {
	err = v.call("nvim_get_color_map", &colorMap)
	return colorMap, err
}

// ColorMap returns a map of color names and RGB values.
//
// Keys are color names (e.g. "Aqua") and values are 24-bit RGB color values (e.g. 65535).
//
// The returns map is color names and RGB values.
//
// See: [nvim_get_color_map()]
//
// [nvim_get_color_map()]: https://neovim.io/doc/user/api.html#nvim_get_color_map()
func (b *Batch) ColorMap(colorMap *map[string]int) {
	b.call("nvim_get_color_map", colorMap)
}

// Context gets a map of the current editor state.
// This API still under development.
//
// The opts arg is optional parameters.
// Key is "types".
//
// List of context-types to gather, or empty for "all" context.
//
//	regs
//	jumps
//	bufs
//	gvars
//	funcs
//	sfuncs
//
// See: [nvim_get_context()]
//
// [nvim_get_context()]: https://neovim.io/doc/user/api.html#nvim_get_context()
func (v *Nvim) Context(opts map[string][]string) (context map[string]any, err error) {
	err = v.call("nvim_get_context", &context, opts)
	return context, err
}

// Context gets a map of the current editor state.
// This API still under development.
//
// The opts arg is optional parameters.
// Key is "types".
//
// List of context-types to gather, or empty for "all" context.
//
//	regs
//	jumps
//	bufs
//	gvars
//	funcs
//	sfuncs
//
// See: [nvim_get_context()]
//
// [nvim_get_context()]: https://neovim.io/doc/user/api.html#nvim_get_context()
func (b *Batch) Context(opts map[string][]string, context *map[string]any) {
	b.call("nvim_get_context", context, opts)
}

// LoadContext Sets the current editor state from the given context map.
//
// See: [nvim_load_context()]
//
// [nvim_load_context()]: https://neovim.io/doc/user/api.html#nvim_load_context()
func (v *Nvim) LoadContext(context map[string]any, result any) error {
	return v.call("nvim_load_context", result, context)
}

// LoadContext Sets the current editor state from the given context map.
//
// See: [nvim_load_context()]
//
// [nvim_load_context()]: https://neovim.io/doc/user/api.html#nvim_load_context()
func (b *Batch) LoadContext(context map[string]any, result any) {
	b.call("nvim_load_context", &result, context)
}

// Mode gets the current mode.
//
// |mode()| "blocking" is true if Nvim is waiting for input.
//
// See: [nvim_get_mode()]
//
// [nvim_get_mode()]: https://neovim.io/doc/user/api.html#nvim_get_mode()
func (v *Nvim) Mode() (mode *Mode, err error) {
	var result Mode
	err = v.call("nvim_get_mode", &result)
	return &result, err
}

// Mode gets the current mode.
//
// |mode()| "blocking" is true if Nvim is waiting for input.
//
// See: [nvim_get_mode()]
//
// [nvim_get_mode()]: https://neovim.io/doc/user/api.html#nvim_get_mode()
func (b *Batch) Mode(mode *Mode) {
	b.call("nvim_get_mode", mode)
}

// KeyMap gets a list of global (non-buffer-local) |mapping| definitions.
//
// The mode arg is the mode short-name, like "n", "i", "v" or etc.
//
// See: [nvim_get_keymap()]
//
// [nvim_get_keymap()]: https://neovim.io/doc/user/api.html#nvim_get_keymap()
func (v *Nvim) KeyMap(mode string) (maps []*Mapping, err error) {
	err = v.call("nvim_get_keymap", &maps, mode)
	return maps, err
}

// KeyMap gets a list of global (non-buffer-local) |mapping| definitions.
//
// The mode arg is the mode short-name, like "n", "i", "v" or etc.
//
// See: [nvim_get_keymap()]
//
// [nvim_get_keymap()]: https://neovim.io/doc/user/api.html#nvim_get_keymap()
func (b *Batch) KeyMap(mode string, maps *[]*Mapping) {
	b.call("nvim_get_keymap", maps, mode)
}

// SetKeyMap sets a global mapping for the given mode.
//
// To set a buffer-local mapping, use SetBufferKeyMap().
//
// Unlike :map, leading/trailing whitespace is accepted as part of the {lhs}
// or {rhs}.
// Empty {rhs} is <Nop>. keycodes are replaced as usual.
//
//	mode
//
// mode short-name (map command prefix: "n", "i", "v", "x", ) or "!" for :map!, or empty string for :map.
//
//	lhs
//
// Left-hand-side {lhs} of the mapping.
//
//	rhs
//
// Right-hand-side {rhs} of the mapping.
//
//	opts
//
// Optional parameters map. Accepts all ":map-arguments" as keys excluding "buffer" but including "noremap".
// Values are Booleans. Unknown key is an error.
//
// See: [nvim_set_keymap()]
//
// [nvim_set_keymap()]: https://neovim.io/doc/user/api.html#nvim_set_keymap()
func (v *Nvim) SetKeyMap(mode string, lhs string, rhs string, opts map[string]bool) error {
	return v.call("nvim_set_keymap", nil, mode, lhs, rhs, opts)
}

// SetKeyMap sets a global mapping for the given mode.
//
// To set a buffer-local mapping, use SetBufferKeyMap().
//
// Unlike :map, leading/trailing whitespace is accepted as part of the {lhs}
// or {rhs}.
// Empty {rhs} is <Nop>. keycodes are replaced as usual.
//
//	mode
//
// mode short-name (map command prefix: "n", "i", "v", "x", ) or "!" for :map!, or empty string for :map.
//
//	lhs
//
// Left-hand-side {lhs} of the mapping.
//
//	rhs
//
// Right-hand-side {rhs} of the mapping.
//
//	opts
//
// Optional parameters map. Accepts all ":map-arguments" as keys excluding "buffer" but including "noremap".
// Values are Booleans. Unknown key is an error.
//
// See: [nvim_set_keymap()]
//
// [nvim_set_keymap()]: https://neovim.io/doc/user/api.html#nvim_set_keymap()
func (b *Batch) SetKeyMap(mode string, lhs string, rhs string, opts map[string]bool) {
	b.call("nvim_set_keymap", nil, mode, lhs, rhs, opts)
}

// DeleteKeyMap unmaps a global mapping for the given mode.
//
// To unmap a buffer-local mapping, use DeleteBufferKeyMap().
//
// See: [nvim_del_keymap()]
//
// [nvim_del_keymap()]: https://neovim.io/doc/user/api.html#nvim_del_keymap()
func (v *Nvim) DeleteKeyMap(mode string, lhs string) error {
	return v.call("nvim_del_keymap", nil, mode, lhs)
}

// DeleteKeyMap unmaps a global mapping for the given mode.
//
// To unmap a buffer-local mapping, use DeleteBufferKeyMap().
//
// See: [nvim_del_keymap()]
//
// [nvim_del_keymap()]: https://neovim.io/doc/user/api.html#nvim_del_keymap()
func (b *Batch) DeleteKeyMap(mode string, lhs string) {
	b.call("nvim_del_keymap", nil, mode, lhs)
}

// APIInfo returns a 2-tuple (Array), where item 0 is the current channel id and item
// 1 is the "api-metadata" map (Dictionary).
//
// Returns 2-tuple [{channel-id}, {api-metadata}].
//
// See: [nvim_get_api_info()]
//
// [nvim_get_api_info()]: https://neovim.io/doc/user/api.html#nvim_get_api_info()
func (v *Nvim) APIInfo() (apiInfo []any, err error) {
	err = v.call("nvim_get_api_info", &apiInfo)
	return apiInfo, err
}

// APIInfo returns a 2-tuple (Array), where item 0 is the current channel id and item
// 1 is the "api-metadata" map (Dictionary).
//
// Returns 2-tuple [{channel-id}, {api-metadata}].
//
// See: [nvim_get_api_info()]
//
// [nvim_get_api_info()]: https://neovim.io/doc/user/api.html#nvim_get_api_info()
func (b *Batch) APIInfo(apiInfo *[]any) {
	b.call("nvim_get_api_info", apiInfo)
}

// SetClientInfo self-identifies the client.
//
// The client/plugin/application should call this after connecting, to provide
// hints about its identity and purpose, for debugging and orchestration.
//
// Can be called more than once; the caller should merge old info if
// appropriate. Example: library first identifies the channel, then a plugin
// using that library later identifies itself.
//
// See: [nvim_set_client_info()]
//
// [nvim_set_client_info()]: https://neovim.io/doc/user/api.html#nvim_set_client_info()
func (v *Nvim) SetClientInfo(name string, version ClientVersion, typ ClientType, methods map[string]*ClientMethod, attributes ClientAttributes) error {
	return v.call("nvim_set_client_info", nil, name, version, typ, methods, attributes)
}

// SetClientInfo self-identifies the client.
//
// The client/plugin/application should call this after connecting, to provide
// hints about its identity and purpose, for debugging and orchestration.
//
// Can be called more than once; the caller should merge old info if
// appropriate. Example: library first identifies the channel, then a plugin
// using that library later identifies itself.
//
// See: [nvim_set_client_info()]
//
// [nvim_set_client_info()]: https://neovim.io/doc/user/api.html#nvim_set_client_info()
func (b *Batch) SetClientInfo(name string, version ClientVersion, typ ClientType, methods map[string]*ClientMethod, attributes ClientAttributes) {
	b.call("nvim_set_client_info", nil, name, version, typ, methods, attributes)
}

// ChannelInfo get information about a channel.
//
// Rreturns Dictionary describing a channel, with these keys:
//
//	stream
//
// The stream underlying the channel. value are:
//
//	stdio
//
// stdin and stdout of this Nvim instance.
//
//	stderr
//
// stderr of this Nvim instance.
//
//	socket
//
// TCP/IP socket or named pipe.
//
//	job
//
// job with communication over its stdio.
//
//	mode
//
// How data received on the channel is interpreted. value are:
//
//	bytes
//
// send and receive raw bytes.
//
//	terminal
//
// A terminal instance interprets ASCII sequences.
//
//	rpc
//
// RPC communication on the channel is active.
//
//	pty
//
// Name of pseudoterminal, if one is used (optional).
// On a POSIX system, this will be a device path like /dev/pts/1.
// Even if the name is unknown, the key will still be present to indicate a pty is used.
// This is currently the case when using winpty on windows.
//
//	buffer
//
// Buffer with connected |terminal| instance (optional).
//
//	client
//
// Information about the client on the other end of the RPC channel, if it has added it using SetClientInfo() (optional).
//
// See: [nvim_get_chan_info()]
//
// [nvim_get_chan_info()]: https://neovim.io/doc/user/api.html#nvim_get_chan_info()
func (v *Nvim) ChannelInfo(channelID int) (channel *Channel, err error) {
	var result Channel
	err = v.call("nvim_get_chan_info", &result, channelID)
	return &result, err
}

// ChannelInfo get information about a channel.
//
// Rreturns Dictionary describing a channel, with these keys:
//
//	stream
//
// The stream underlying the channel. value are:
//
//	stdio
//
// stdin and stdout of this Nvim instance.
//
//	stderr
//
// stderr of this Nvim instance.
//
//	socket
//
// TCP/IP socket or named pipe.
//
//	job
//
// job with communication over its stdio.
//
//	mode
//
// How data received on the channel is interpreted. value are:
//
//	bytes
//
// send and receive raw bytes.
//
//	terminal
//
// A terminal instance interprets ASCII sequences.
//
//	rpc
//
// RPC communication on the channel is active.
//
//	pty
//
// Name of pseudoterminal, if one is used (optional).
// On a POSIX system, this will be a device path like /dev/pts/1.
// Even if the name is unknown, the key will still be present to indicate a pty is used.
// This is currently the case when using winpty on windows.
//
//	buffer
//
// Buffer with connected |terminal| instance (optional).
//
//	client
//
// Information about the client on the other end of the RPC channel, if it has added it using SetClientInfo() (optional).
//
// See: [nvim_get_chan_info()]
//
// [nvim_get_chan_info()]: https://neovim.io/doc/user/api.html#nvim_get_chan_info()
func (b *Batch) ChannelInfo(channelID int, channel *Channel) {
	b.call("nvim_get_chan_info", channel, channelID)
}

// Channels get information about all open channels.
//
// See: [nvim_list_chans()]
//
// [nvim_list_chans()]: https://neovim.io/doc/user/api.html#nvim_list_chans()
func (v *Nvim) Channels() (channels []*Channel, err error) {
	err = v.call("nvim_list_chans", &channels)
	return channels, err
}

// Channels get information about all open channels.
//
// See: [nvim_list_chans()]
//
// [nvim_list_chans()]: https://neovim.io/doc/user/api.html#nvim_list_chans()
func (b *Batch) Channels(channels *[]*Channel) {
	b.call("nvim_list_chans", channels)
}

// UIs gets a list of dictionaries representing attached UIs.
//
// See: [nvim_list_uis()]
//
// [nvim_list_uis()]: https://neovim.io/doc/user/api.html#nvim_list_uis()
func (v *Nvim) UIs() (uis []*UI, err error) {
	err = v.call("nvim_list_uis", &uis)
	return uis, err
}

// UIs gets a list of dictionaries representing attached UIs.
//
// See: [nvim_list_uis()]
//
// [nvim_list_uis()]: https://neovim.io/doc/user/api.html#nvim_list_uis()
func (b *Batch) UIs(uis *[]*UI) {
	b.call("nvim_list_uis", uis)
}

// ProcChildren gets the immediate children of process `pid`.
//
// See: [nvim_get_proc_children()]
//
// [nvim_get_proc_children()]: https://neovim.io/doc/user/api.html#nvim_get_proc_children()
func (v *Nvim) ProcChildren(pid int) (processes []uint, err error) {
	err = v.call("nvim_get_proc_children", &processes, pid)
	return processes, err
}

// ProcChildren gets the immediate children of process `pid`.
//
// See: [nvim_get_proc_children()]
//
// [nvim_get_proc_children()]: https://neovim.io/doc/user/api.html#nvim_get_proc_children()
func (b *Batch) ProcChildren(pid int, processes *[]uint) {
	b.call("nvim_get_proc_children", processes, pid)
}

// Proc gets info describing process "pid".
//
// See: [nvim_get_proc()]
//
// [nvim_get_proc()]: https://neovim.io/doc/user/api.html#nvim_get_proc()
func (v *Nvim) Proc(pid int) (process Process, err error) {
	err = v.call("nvim_get_proc", &process, pid)
	return process, err
}

// Proc gets info describing process "pid".
//
// See: [nvim_get_proc()]
//
// [nvim_get_proc()]: https://neovim.io/doc/user/api.html#nvim_get_proc()
func (b *Batch) Proc(pid int, process *Process) {
	b.call("nvim_get_proc", process, pid)
}

// SelectPopupmenuItem selects an item in the completion popupmenu.
//
// If |ins-completion| is not active this API call is silently ignored.
// Useful for an external UI using |ui-popupmenu| to control the popupmenu
// with the mouse. Can also be used in a mapping; use <cmd> |:map-cmd| to
// ensure the mapping doesn't end completion mode.
//
// opts optional parameters. Reserved for future use.
//
// See: [nvim_select_popupmenu_item()]
//
// [nvim_select_popupmenu_item()]: https://neovim.io/doc/user/api.html#nvim_select_popupmenu_item()
func (v *Nvim) SelectPopupmenuItem(item int, insert bool, finish bool, opts map[string]any) error {
	return v.call("nvim_select_popupmenu_item", nil, item, insert, finish, opts)
}

// SelectPopupmenuItem selects an item in the completion popupmenu.
//
// If |ins-completion| is not active this API call is silently ignored.
// Useful for an external UI using |ui-popupmenu| to control the popupmenu
// with the mouse. Can also be used in a mapping; use <cmd> |:map-cmd| to
// ensure the mapping doesn't end completion mode.
//
// opts optional parameters. Reserved for future use.
//
// See: [nvim_select_popupmenu_item()]
//
// [nvim_select_popupmenu_item()]: https://neovim.io/doc/user/api.html#nvim_select_popupmenu_item()
func (b *Batch) SelectPopupmenuItem(item int, insert bool, finish bool, opts map[string]any) {
	b.call("nvim_select_popupmenu_item", nil, item, insert, finish, opts)
}

// DeleteMark deletes a uppercase/file named mark.
// See |help mark-motions|.
//
// See: [nvim_del_mark()]
//
// [nvim_del_mark()]: https://neovim.io/doc/user/api.html#nvim_del_mark()
func (v *Nvim) DeleteMark(name string) (deleted bool, err error) {
	err = v.call("nvim_del_mark", &deleted, name)
	return deleted, err
}

// DeleteMark deletes a uppercase/file named mark.
// See |help mark-motions|.
//
// See: [nvim_del_mark()]
//
// [nvim_del_mark()]: https://neovim.io/doc/user/api.html#nvim_del_mark()
func (b *Batch) DeleteMark(name string, deleted *bool) {
	b.call("nvim_del_mark", deleted, name)
}

// Mark returns a tuple (row, col, buffer, buffername) representing the position of
// the uppercase/file named mark.
// See |help mark-motions|.
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_get_mark()]
//
// [nvim_get_mark()]: https://neovim.io/doc/user/api.html#nvim_get_mark()
func (v *Nvim) Mark(name string, opts map[string]any) (mark *Mark, err error) {
	var result Mark
	err = v.call("nvim_get_mark", &result, name, opts)
	return &result, err
}

// Mark returns a tuple (row, col, buffer, buffername) representing the position of
// the uppercase/file named mark.
// See |help mark-motions|.
//
// opts is optional parameters. Reserved for future use.
//
// See: [nvim_get_mark()]
//
// [nvim_get_mark()]: https://neovim.io/doc/user/api.html#nvim_get_mark()
func (b *Batch) Mark(name string, opts map[string]any, mark *Mark) {
	b.call("nvim_get_mark", mark, name, opts)
}

// EvalStatusLine evaluates statusline string.
//
// opts optional parameters.
//
//	winid (int)
//
// Window ID of the window to use as context for statusline.
//
//	maxwidth (int)
//
// Maximum width of statusline.
//
//	fillchar (string)
//
// Character to fill blank spaces in the statusline (see 'fillchars').
//
//	highlights (bool)
//
// Return highlight information.
//
//	use_tabline (bool)
//
// Evaluate tabline instead of statusline. When true, {winid} is ignored.
//
// See: [nvim_eval_statusline()]
//
// [nvim_eval_statusline()]: https://neovim.io/doc/user/api.html#nvim_eval_statusline()
func (v *Nvim) EvalStatusLine(name string, opts map[string]any) (statusline map[string]any, err error) {
	err = v.call("nvim_eval_statusline", &statusline, name, opts)
	return statusline, err
}

// EvalStatusLine evaluates statusline string.
//
// opts optional parameters.
//
//	winid (int)
//
// Window ID of the window to use as context for statusline.
//
//	maxwidth (int)
//
// Maximum width of statusline.
//
//	fillchar (string)
//
// Character to fill blank spaces in the statusline (see 'fillchars').
//
//	highlights (bool)
//
// Return highlight information.
//
//	use_tabline (bool)
//
// Evaluate tabline instead of statusline. When true, {winid} is ignored.
//
// See: [nvim_eval_statusline()]
//
// [nvim_eval_statusline()]: https://neovim.io/doc/user/api.html#nvim_eval_statusline()
func (b *Batch) EvalStatusLine(name string, opts map[string]any, statusline *map[string]any) {
	b.call("nvim_eval_statusline", statusline, name, opts)
}

// WindowBuffer gets the current buffer in a window.
//
// See: [nvim_win_get_buf()]
//
// [nvim_win_get_buf()]: https://neovim.io/doc/user/api.html#nvim_win_get_buf()
func (v *Nvim) WindowBuffer(window Window) (buffer Buffer, err error) {
	err = v.call("nvim_win_get_buf", &buffer, window)
	return buffer, err
}

// WindowBuffer gets the current buffer in a window.
//
// See: [nvim_win_get_buf()]
//
// [nvim_win_get_buf()]: https://neovim.io/doc/user/api.html#nvim_win_get_buf()
func (b *Batch) WindowBuffer(window Window, buffer *Buffer) {
	b.call("nvim_win_get_buf", buffer, window)
}

// SetBufferToWindow Sets the current buffer in a window, without side-effects.
//
// See: [nvim_win_set_buf()]
//
// [nvim_win_set_buf()]: https://neovim.io/doc/user/api.html#nvim_win_set_buf()
func (v *Nvim) SetBufferToWindow(window Window, buffer Buffer) error {
	return v.call("nvim_win_set_buf", nil, window, buffer)
}

// SetBufferToWindow Sets the current buffer in a window, without side-effects.
//
// See: [nvim_win_set_buf()]
//
// [nvim_win_set_buf()]: https://neovim.io/doc/user/api.html#nvim_win_set_buf()
func (b *Batch) SetBufferToWindow(window Window, buffer Buffer) {
	b.call("nvim_win_set_buf", nil, window, buffer)
}

// WindowCursor gets the (1,0)-indexed cursor position in the window.
//
// See: [nvim_win_get_cursor()]
//
// [nvim_win_get_cursor()]: https://neovim.io/doc/user/api.html#nvim_win_get_cursor()
func (v *Nvim) WindowCursor(window Window) (pos [2]int, err error) {
	err = v.call("nvim_win_get_cursor", &pos, window)
	return pos, err
}

// WindowCursor gets the (1,0)-indexed cursor position in the window.
//
// See: [nvim_win_get_cursor()]
//
// [nvim_win_get_cursor()]: https://neovim.io/doc/user/api.html#nvim_win_get_cursor()
func (b *Batch) WindowCursor(window Window, pos *[2]int) {
	b.call("nvim_win_get_cursor", pos, window)
}

// SetWindowCursor sets the (1,0)-indexed cursor position in the window.
//
// See: [nvim_win_set_cursor()]
//
// [nvim_win_set_cursor()]: https://neovim.io/doc/user/api.html#nvim_win_set_cursor()
func (v *Nvim) SetWindowCursor(window Window, pos [2]int) error {
	return v.call("nvim_win_set_cursor", nil, window, pos)
}

// SetWindowCursor sets the (1,0)-indexed cursor position in the window.
//
// See: [nvim_win_set_cursor()]
//
// [nvim_win_set_cursor()]: https://neovim.io/doc/user/api.html#nvim_win_set_cursor()
func (b *Batch) SetWindowCursor(window Window, pos [2]int) {
	b.call("nvim_win_set_cursor", nil, window, pos)
}

// WindowHeight returns the window height.
//
// See: [nvim_win_get_height()]
//
// [nvim_win_get_height()]: https://neovim.io/doc/user/api.html#nvim_win_get_height()
func (v *Nvim) WindowHeight(window Window) (height int, err error) {
	err = v.call("nvim_win_get_height", &height, window)
	return height, err
}

// WindowHeight returns the window height.
//
// See: [nvim_win_get_height()]
//
// [nvim_win_get_height()]: https://neovim.io/doc/user/api.html#nvim_win_get_height()
func (b *Batch) WindowHeight(window Window, height *int) {
	b.call("nvim_win_get_height", height, window)
}

// SetWindowHeight Sets the window height. This will only succeed if the screen is split horizontally.
//
// See: [nvim_win_set_height()]
//
// [nvim_win_set_height()]: https://neovim.io/doc/user/api.html#nvim_win_set_height()
func (v *Nvim) SetWindowHeight(window Window, height int) error {
	return v.call("nvim_win_set_height", nil, window, height)
}

// SetWindowHeight Sets the window height. This will only succeed if the screen is split horizontally.
//
// See: [nvim_win_set_height()]
//
// [nvim_win_set_height()]: https://neovim.io/doc/user/api.html#nvim_win_set_height()
func (b *Batch) SetWindowHeight(window Window, height int) {
	b.call("nvim_win_set_height", nil, window, height)
}

// WindowWidth returns the window width.
//
// See: [nvim_win_get_width()]
//
// [nvim_win_get_width()]: https://neovim.io/doc/user/api.html#nvim_win_get_width()
func (v *Nvim) WindowWidth(window Window) (width int, err error) {
	err = v.call("nvim_win_get_width", &width, window)
	return width, err
}

// WindowWidth returns the window width.
//
// See: [nvim_win_get_width()]
//
// [nvim_win_get_width()]: https://neovim.io/doc/user/api.html#nvim_win_get_width()
func (b *Batch) WindowWidth(window Window, width *int) {
	b.call("nvim_win_get_width", width, window)
}

// SetWindowWidth Sets the window width. This will only succeed if the screen is split vertically.
//
// See: [nvim_win_set_width()]
//
// [nvim_win_set_width()]: https://neovim.io/doc/user/api.html#nvim_win_set_width()
func (v *Nvim) SetWindowWidth(window Window, width int) error {
	return v.call("nvim_win_set_width", nil, window, width)
}

// SetWindowWidth Sets the window width. This will only succeed if the screen is split vertically.
//
// See: [nvim_win_set_width()]
//
// [nvim_win_set_width()]: https://neovim.io/doc/user/api.html#nvim_win_set_width()
func (b *Batch) SetWindowWidth(window Window, width int) {
	b.call("nvim_win_set_width", nil, window, width)
}

// WindowVar gets a window-scoped (w:) variable.
//
// See: [nvim_win_get_var()]
//
// [nvim_win_get_var()]: https://neovim.io/doc/user/api.html#nvim_win_get_var()
func (v *Nvim) WindowVar(window Window, name string, result any) error {
	return v.call("nvim_win_get_var", result, window, name)
}

// WindowVar gets a window-scoped (w:) variable.
//
// See: [nvim_win_get_var()]
//
// [nvim_win_get_var()]: https://neovim.io/doc/user/api.html#nvim_win_get_var()
func (b *Batch) WindowVar(window Window, name string, result any) {
	b.call("nvim_win_get_var", &result, window, name)
}

// SetWindowVar sets a window-scoped (w:) variable.
//
// See: [nvim_win_set_var()]
//
// [nvim_win_set_var()]: https://neovim.io/doc/user/api.html#nvim_win_set_var()
func (v *Nvim) SetWindowVar(window Window, name string, value any) error {
	return v.call("nvim_win_set_var", nil, window, name, value)
}

// SetWindowVar sets a window-scoped (w:) variable.
//
// See: [nvim_win_set_var()]
//
// [nvim_win_set_var()]: https://neovim.io/doc/user/api.html#nvim_win_set_var()
func (b *Batch) SetWindowVar(window Window, name string, value any) {
	b.call("nvim_win_set_var", nil, window, name, value)
}

// DeleteWindowVar removes a window-scoped (w:) variable.
//
// See: [nvim_win_del_var()]
//
// [nvim_win_del_var()]: https://neovim.io/doc/user/api.html#nvim_win_del_var()
func (v *Nvim) DeleteWindowVar(window Window, name string) error {
	return v.call("nvim_win_del_var", nil, window, name)
}

// DeleteWindowVar removes a window-scoped (w:) variable.
//
// See: [nvim_win_del_var()]
//
// [nvim_win_del_var()]: https://neovim.io/doc/user/api.html#nvim_win_del_var()
func (b *Batch) DeleteWindowVar(window Window, name string) {
	b.call("nvim_win_del_var", nil, window, name)
}

// WindowPosition gets the window position in display cells. First position is zero.
//
// See: [nvim_win_get_position()]
//
// [nvim_win_get_position()]: https://neovim.io/doc/user/api.html#nvim_win_get_position()
func (v *Nvim) WindowPosition(window Window) (pos [2]int, err error) {
	err = v.call("nvim_win_get_position", &pos, window)
	return pos, err
}

// WindowPosition gets the window position in display cells. First position is zero.
//
// See: [nvim_win_get_position()]
//
// [nvim_win_get_position()]: https://neovim.io/doc/user/api.html#nvim_win_get_position()
func (b *Batch) WindowPosition(window Window, pos *[2]int) {
	b.call("nvim_win_get_position", pos, window)
}

// WindowTabpage gets the window tabpage.
//
// See: [nvim_win_get_tabpage()]
//
// [nvim_win_get_tabpage()]: https://neovim.io/doc/user/api.html#nvim_win_get_tabpage()
func (v *Nvim) WindowTabpage(window Window) (tabpage Tabpage, err error) {
	err = v.call("nvim_win_get_tabpage", &tabpage, window)
	return tabpage, err
}

// WindowTabpage gets the window tabpage.
//
// See: [nvim_win_get_tabpage()]
//
// [nvim_win_get_tabpage()]: https://neovim.io/doc/user/api.html#nvim_win_get_tabpage()
func (b *Batch) WindowTabpage(window Window, tabpage *Tabpage) {
	b.call("nvim_win_get_tabpage", tabpage, window)
}

// WindowNumber gets the window number.
//
// See: [nvim_win_get_number()]
//
// [nvim_win_get_number()]: https://neovim.io/doc/user/api.html#nvim_win_get_number()
func (v *Nvim) WindowNumber(window Window) (number int, err error) {
	err = v.call("nvim_win_get_number", &number, window)
	return number, err
}

// WindowNumber gets the window number.
//
// See: [nvim_win_get_number()]
//
// [nvim_win_get_number()]: https://neovim.io/doc/user/api.html#nvim_win_get_number()
func (b *Batch) WindowNumber(window Window, number *int) {
	b.call("nvim_win_get_number", number, window)
}

// IsWindowValid checks if a window is valid.
//
// See: [nvim_win_is_valid()]
//
// [nvim_win_is_valid()]: https://neovim.io/doc/user/api.html#nvim_win_is_valid()
func (v *Nvim) IsWindowValid(window Window) (valid bool, err error) {
	err = v.call("nvim_win_is_valid", &valid, window)
	return valid, err
}

// IsWindowValid checks if a window is valid.
//
// See: [nvim_win_is_valid()]
//
// [nvim_win_is_valid()]: https://neovim.io/doc/user/api.html#nvim_win_is_valid()
func (b *Batch) IsWindowValid(window Window, valid *bool) {
	b.call("nvim_win_is_valid", valid, window)
}

// SetWindowConfig configure window position. Currently this is only used to configure
// floating and external windows (including changing a split window to these types).
//
// When reconfiguring a floating window, absent option keys will not be
// changed. "row"/"col" and "relative" must be reconfigured together.
//
// See documentation at OpenWindow, for the meaning of parameters.
//
// See: [nvim_win_set_config()]
//
// [nvim_win_set_config()]: https://neovim.io/doc/user/api.html#nvim_win_set_config()
func (v *Nvim) SetWindowConfig(window Window, config *WindowConfig) error {
	return v.call("nvim_win_set_config", nil, window, config)
}

// SetWindowConfig configure window position. Currently this is only used to configure
// floating and external windows (including changing a split window to these types).
//
// When reconfiguring a floating window, absent option keys will not be
// changed. "row"/"col" and "relative" must be reconfigured together.
//
// See documentation at OpenWindow, for the meaning of parameters.
//
// See: [nvim_win_set_config()]
//
// [nvim_win_set_config()]: https://neovim.io/doc/user/api.html#nvim_win_set_config()
func (b *Batch) SetWindowConfig(window Window, config *WindowConfig) {
	b.call("nvim_win_set_config", nil, window, config)
}

// WindowConfig return window configuration.
//
// The returned value may be given to OpenWindow.
//
// Relative will be an empty string for normal windows.
//
// See: [nvim_win_get_config()]
//
// [nvim_win_get_config()]: https://neovim.io/doc/user/api.html#nvim_win_get_config()
func (v *Nvim) WindowConfig(window Window) (config *WindowConfig, err error) {
	var result WindowConfig
	err = v.call("nvim_win_get_config", &result, window)
	return &result, err
}

// WindowConfig return window configuration.
//
// The returned value may be given to OpenWindow.
//
// Relative will be an empty string for normal windows.
//
// See: [nvim_win_get_config()]
//
// [nvim_win_get_config()]: https://neovim.io/doc/user/api.html#nvim_win_get_config()
func (b *Batch) WindowConfig(window Window, config *WindowConfig) {
	b.call("nvim_win_get_config", config, window)
}

// HideWindow closes the window and hide the buffer it contains (like ":hide" with a
// windowID).
//
// Like ":hide" the buffer becomes hidden unless another window is editing it,
// or "bufhidden" is "unload", "delete" or "wipe" as opposed to ":close" or
// CloseWindow, which will close the buffer.
//
// See: [nvim_win_hide()]
//
// [nvim_win_hide()]: https://neovim.io/doc/user/api.html#nvim_win_hide()
func (v *Nvim) HideWindow(window Window) error {
	return v.call("nvim_win_hide", nil, window)
}

// HideWindow closes the window and hide the buffer it contains (like ":hide" with a
// windowID).
//
// Like ":hide" the buffer becomes hidden unless another window is editing it,
// or "bufhidden" is "unload", "delete" or "wipe" as opposed to ":close" or
// CloseWindow, which will close the buffer.
//
// See: [nvim_win_hide()]
//
// [nvim_win_hide()]: https://neovim.io/doc/user/api.html#nvim_win_hide()
func (b *Batch) HideWindow(window Window) {
	b.call("nvim_win_hide", nil, window)
}

// CloseWindow Closes the window (like ":close" with a window-ID).
//
// See: [nvim_win_close()]
//
// [nvim_win_close()]: https://neovim.io/doc/user/api.html#nvim_win_close()
func (v *Nvim) CloseWindow(window Window, force bool) error {
	return v.call("nvim_win_close", nil, window, force)
}

// CloseWindow Closes the window (like ":close" with a window-ID).
//
// See: [nvim_win_close()]
//
// [nvim_win_close()]: https://neovim.io/doc/user/api.html#nvim_win_close()
func (b *Batch) CloseWindow(window Window, force bool) {
	b.call("nvim_win_close", nil, window, force)
}

// SetWindowHeightNamespace set highlight namespace for a window. This will use highlights defined in
// this namespace, but fall back to global highlights (ns=0) when missing.
//
// This takes predecence over the 'winhighlight' option.
//
// See: [nvim_win_set_hl_ns()]
//
// [nvim_win_set_hl_ns()]: https://neovim.io/doc/user/api.html#nvim_win_set_hl_ns()
func (v *Nvim) SetWindowHeightNamespace(window Window, nsID int) error {
	return v.call("nvim_win_set_hl_ns", nil, window, nsID)
}

// SetWindowHeightNamespace set highlight namespace for a window. This will use highlights defined in
// this namespace, but fall back to global highlights (ns=0) when missing.
//
// This takes predecence over the 'winhighlight' option.
//
// See: [nvim_win_set_hl_ns()]
//
// [nvim_win_set_hl_ns()]: https://neovim.io/doc/user/api.html#nvim_win_set_hl_ns()
func (b *Batch) SetWindowHeightNamespace(window Window, nsID int) {
	b.call("nvim_win_set_hl_ns", nil, window, nsID)
}
